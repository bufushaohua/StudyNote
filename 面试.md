### 面试

#### Hibernate与MyBatis

**Hibernate优点：**

		hibernate框架是一种开源的。轻量级的ORM框架，它允许将普通的、传统的Java对象（POJO)映射称为持久化类，允许应用程序以面向象的方式来操作POJO，而Hibernate框架则负责将这种操作转换成底层的SQL操作

**缺点：**

~~~markdown
在一些特定的环境下，Hibernate这种一站式的解决方案未必适合
比如：
	- 系统的而部分或全部数据来自现有数据库，出于安全考虑，只对开发团队提供几条Select SQL（或存储过程）以获取所需数据，具体的表结构不予公开。
	- 开发规范中要求，所有涉及到业务逻辑部分的数据库操作，必须在数据层由存储过程实现
	- 系统数据处理量巨大，性能要求极为苛刻，这旺旺意味着我们必须通过经过高度优化的SQL语句（或存储过程）才能达到系统性能设计指标
~~~

> 使用MyBatis提供的ORM机制，对业务逻辑实现人员而言，面对的是纯粹的Java对象，这一层与通过Hibernate实现ORM而言基本一致。而对于具体的数据操作，Hibernate会自动生成SQL语句，但MyBatis则并不会为程序员在运行期自动生成SQL语句。具体的SQL需要程序员编写，然后通过映射文件，将SQL所需的参数以及返回的结果字段映射到指定的POJO

**MyBatis的优点**

~~~markdown
- MyBatis是Apache组织提供的一个轻量级持久层框架，是一个支持普通SQL查询、存储过程和高级映射的优秀持久层框架。MyBatis消除了几乎所有的JDBC代码和参数的手工设置过程以及对结果集的检索封装。MyBatis可以使用简单的XML或注解进行配置和原始映射，将接口和Java的POJO映射成数据库中的记录
- MyBatis作为持久层框架，其主要思想是将程序中大量SQL语句剥离出来，配置在配置文件中，实现SQL的灵活配置。
- 这样做的好处是将SQL与程序代码分离，可以在不修改程序代码的情况下，直接在配置文件中修改SQL
~~~

### Spring MVC的常用注解

#### @Controller

~~~markdown
- 使用该注解不需要继承特定的父类或实现特点的接口
		- Controller接口的实现类只能处理一个单一请求动作，而使用注解的控制器可以同时处理多个请求动作，更加灵活

为保证Spring能找到控制器，需要完成以下两件事情
	- 在SpringMVC的配置文件的头文件中引入spring-context
	- 使用<context:component-scan />元素，功能是：启动包扫描功能，以便注册带有@Controller、@Service、@repository、@Component等注解的类成为Spring的Bean
	- 使用<context:component-scan base-package = "类的全类名" />
~~~

> SpringMVC用于参数绑定的注解有很多， 根据处理的request的不同内容部分可以分为四类：
>
> 	- 处理request body部分的注解： @RequestParam 、@RequestBody
> 	- 处理request uri部分的注解： @PathVariable
> 	- 处理request header部分的注解： @RequestHeader 、@CookieValue
> 	- 处理attribute类型的注解： @SessionAttributes、 @ModelAttribute

#### @RequestMapping

~~~markdown
@RequestMapping可以用来注释一个控制器类，在这种情况下，所有方法都将映射为相对于类级别的请求，表示该控制器处理的所有请求都被映射到value属性所指示的路径下
~~~

| 属性     | 类型            | 是否必要 | 说明                                                         |
| -------- | --------------- | -------- | ------------------------------------------------------------ |
| value    | String[]        | 否       | 用于将指定请求的实际地址映射到方法上                         |
| name     | String          | 否       | 给映射地址指定一个别名                                       |
| method   | RequestMethod[] | 否       | 映射指定请求的方法类型，包括GET、POST、PUT、DELETE、HEAD、OPTIONS、PATCH、TRACE |
| consumes | String[]        | 否       | 指定处理请求的提交内容类型（Content-Type）、例如application/json、text/html等 |
| produces | String[]        | 否       | 指定返回的内容类型、返回的内容类型必须是request请求头（Accept）中所包含的类型 |
| params   | String[]        | 否       | 指定request中必须包含某些参数值时，才让该方法处理            |
| headers  | String[]        | 否       | 指定request中必须包含某些指定的head值，才能让该方法处理请求  |
| Path     | String[]        | 否       | 在Servlet环境中只哟偶:uri环境路径映射（例如：“/myPath.do”），也支持如ant的基于路径模式（例如“/myPath/*,”）在方法层面上，支持相对路径（例如："edit.do"） |

> 对于MVC框架，控制器（Controller）执行业务逻辑，用于产生模型数据（Model），而视图（View）则用于渲染模型数据

#### @RequestParam

~~~markdown
该注解类型用于将指定的请求参数赋值给方法中的形参
~~~

| 属性         | 类型    | 是否必要 | 说明                           |
| ------------ | ------- | -------- | ------------------------------ |
| name         | String  | 否       | 指定请求头绑定的名称           |
| value        | String  | 否       | name属性的别名                 |
| required     | boolean | 否       | 指定参数是否必须绑定           |
| defaultValue | String  | 否       | 如果没有传递参数而使用的默认值 |

~~~java
/*
	@PathVariable注解只支持一个属性value，类型为String，表示绑定的名称，如果省略则默认绑定同名参数
*/
@RequestMapping(value="/pathVariableTest/{userId}")
public void pathVariableTest(@PathVariable Integer userId)
~~~

#### @PathVariable

> 注解类型用于将请求的头信息区数据映射到功能处理方法的参数上

| 属性         | 类型    | 是否必要 | 说明                           |
| ------------ | ------- | -------- | ------------------------------ |
| name         | String  | 否       | 指定请求头绑定的名称           |
| value        | String  | 否       | name属性的别名                 |
| required     | Boolean | 否       | 指定参数是否必须绑定           |
| defaultValue | String  | 否       | 如果没有传递参数而使用的默认值 |

#### @RequestHeader

#### @CookieValue

#### @SessionAttributes

#### @ModelAttribute

#### 转换Json数据

#### 转换XML数据