## :pencil:牛客——Java基础

> **类的加载顺序**。
>
> (1) 父类静态对象和静态代码块
>
> (2) 子类静态对象和静态代码块
>
> (3) 父类非静态对象和非静态代码块
>
> (4) 父类构造函数
>
> (5) 子类 非静态对象和非静态代码块
>
> (6) 子类构造函数



> 中间件是一种独立的系统软件或服务程序，分布式应用软件借助这种软件在不同的技术之间共享资源。中间件位于客户机/ 服务器的操作系统之上，管理计算机资源和网络通讯。是连接两个独立应用程序或独立系统的软件。相连接的系统，即使它们具有不同的接口，但通过中间件相互之间仍能交换信息。执行中间件的一个关键途径是信息传递。通过中间件，应用程序可以工作于多平台或OS环境。
>
> （简单来说，中间件并不能提高内核的效率，一般只是负责网络信息的分发处理）



> 一个Java类的初始化顺序：1. 静态代码块；2. 普通代码块；3. 构造函数。
>
> 其次，静态代码块只加载一次；普通代码块创建几个对象就加载几次。
>
> 所以，我觉得本题的答案应该：
>
> A的静态代码块
>
> A的构造代码块
>
> A的构造函数



> | :检测ture;不具备短路功能，会检查每一个条件，表达式中只要一个ture 就整体返回true
> || :检测true;具备短路功能，一遇到true,就返回true;
> &:检测false;同理上；
> &&：检测false;同理上；



> 1.从地址栏显示来说
>
> forward是服务器请求资源,服务器直接访问目标地址的URL,把那个URL的响应内容读取过来,然后把这些内容再发给浏览器.浏览器根本不知道服务器发送的内容从哪里来的,所以它的地址栏还是原来的地址.
>
> redirect是服务端根据逻辑,发送一个状态码,告诉浏览器重新去请求那个地址.所以地址栏显示的是新的URL.
>
> 2.从数据共享来说
>
> forward:转发页面和转发到的页面可以共享request里面的数据.
>
> redirect:不能共享数据.
>
> 3.从运用地方来说
>
> forward:一般用于用户登陆的时候,根据角色转发到相应的模块.
>
> redirect:一般用于用户注销登陆时返回主页面和跳转到其它的网站等.
>
> 4.从效率来说
>
> forward:高.
>
> redirect:低.



**下面哪些赋值语句是正确的（）**

正确答案: A B D  你的答案: E (错误)

```
long test=012
float f=-412
int other =(int)true
double d=0x12345678
byte b=128
```

> 选ABD
>
> A和B中long和float，正常定义需要加l和f，但是long和float属于基本类型，会进行转化，所以不会报出异常。AB正确
>
> boolean类型不能和任何类型进行转换，会报出类型异常错误。所以C错。
>
> D选项可以这样定义，D正确。
>
> E选项中，byte的取值范围是-128—127。报出异常： cannot convert from int to byte.所以E选项错误。



> ***\*jdk1.8之前\****
>
> ***\*接口\****
>
> 1.多实现
>
> 2.变量类型默认且只能为为public static final
>
> 3.函数类型默认且只能为public，只能有public类型的静态成员函数
>
> 4.非静态成员函数没有方法体，静态成员函数有方法体
>
> 5.子类必须实现所有接口函数
>
> 6.可以有main方法；可以new一个接口，需要在方法体中实现所有接口函数
>
> 7.没有构造器
>
>  
>
> ***\*抽象类\****
>
> 1.单继承
>
> 2.变量类型不限（静态变量+非静态变量）
>
> 3.函数类型不限（静态函数+非静态函数）
>
> 4.非静态函数包含没有方法体的抽象函数. 有方法体的普通函数
>
> 5.子类可以不覆写父类的抽象方法，但子类也要申明为抽象类；子类可以选择覆写父类的非抽象方法
>
> 6.可以有main方法；不可以new一个抽象类
>
> 7.可以有构造器
>
>  
>
> ***\*Jdk1.8\****
>
> ***\*接口中可以有default类型的方法，实现类可以选择实现该方法\****
>
> ***\*意义：\****默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。另一个优势为该方法是可选的，子类可以根据不同的需求Override或默认实现。



> 1.类与类之间的关系为继承，只能单继承，但可以多层继承。 2.类与接口之间的关系为实现，既可以单实现，也可以多实现。 3.接口与接口之间的关系为继承，既可以单继承，也可以多继承。



> 类中实例变量（即成员变量）可以不用初始化，使用相应类型的默认值即可；方法中的定义的局部变量必须初始化，否则编译不通过。



**设int x=1,float y=2,则表达式x/y的值是：（）**

正确答案: D  你的答案: A (错误)

```
0
1
2
以上都不是
```

> 本题的意义在于两点，明白这两点之后题会不会本身就不重要了：①float x = 1；与float x = 1.0f，这两种对于float类型的变量来说定义的方式都是正确的，也是比较常见的笔试题里面考察类型转换的例子，当==第一种情况==时，是将低精度int向上转型到float，是由于java的特性导致而不需要进行强制转换（**因为java是强类型语言，由强类型向弱类型转换需要强制转换，而由弱类型向强类型转换则系统自动转换。**），而==第二种情况==则是比较正式的对于float变量的定义，由于这种类型本身在工作项目中并不常见，常用的带小数的数字我们一般都直接使用double类型，而double类型直接定义是没有问题的：double x = 1.0。而由于float的精度没有double类型高，因此必须对其进行显示的格式书写，如果没有这个f，就默认是double类型了。当然double x = 1.0d也是正确的命名，不信你可以尝试，虽然这是一个令人窒息的操作。②==当多个精度的数字同时进行运算时，最终结果以最高精度为准==。在多数情况下，整数和小数的各级混合运算中，一般结果都是double类型的。但就本题而言，结果是float类型的，因为x，y两个数字精度最高的就是float，所以最终结果是0.5，并且这个0.5是float类型的。为什么说不是double类型呢，当然如果你这样处理：double m = x/y，当然m是double类型的，也不会报错，而如果你写成int m = x/y，编译器报错提示的时候就会让你转换成float或者进行强制转换成int，他是不会提示你转换成double的，尽管这么写并没有报错，原因就是①中所说的向上强转。float转换成double不需要任何提示。



> 重写 要求**两同两小一大原则**， 方法名相同，参数类型相同，子类返回类型小于等于父类方法返回类型， 子类抛出异常小于等于父类方法抛出异常， 子类访问权限大于等于父类方法访问权限。［注意：这里的返回类型必须要在有继承关系的前提下比较］
>
> 重载 方法名必须相同，参数类型必须不同，包括但不限于一项，参数数目，参数类型，参数顺序



**下列哪项不属于jdk1.6垃圾收集器？**

正确答案: D  你的答案: A (错误)

```
Serial收集器
parNew收集器
CMS收集器
G1收集器
```

> 1.Serial收集器 
> 单线程收集器，收集时会暂停所有工作线程（我们将这件事情称之为Stop The World，下称STW），使用复制收集算法，虚拟机运行在Client模式时的默认新生代收集器。 
>
> 2.ParNew收集器 
> ParNew 收集器就是Serial的多线程版本，除了使用多条收集线程外，其余行为包括算法、STW、对象分配规则、回收策略等都与Serial收集器一摸一样。对 应的这种收集器是虚拟机运行在Server模式的默认新生代收集器，在单CPU的环境中，ParNew收集器并不会比Serial收集器有更好的效果。 
>
> 3.Parallel Scavenge收集器 
> Parallel Scavenge收集器（下称PS收集器）也是一个多线程收集器，也是使用复制算法，但它的对象分配规则与回收策略都与ParNew收集器有所不同，它是 以吞吐量最大化（即GC时间占总运行时间最小）为目标的收集器实现，它允许较长时间的STW换取总吞吐量最大化。 
>
> 4.Serial Old收集器 
> Serial Old是单线程收集器，使用标记－整理算法，是老年代的收集器，上面三种都是使用在新生代收集器。 
>
> 5.Parallel Old收集器 
> 老年代版本吞吐量优先收集器，使用多线程和标记－整理算法，JVM 1.6提供，在此之前，新生代使用了PS收集器的话，老年代除Serial Old外别无选择，因为PS无法与CMS收集器配合工作。 
>
> 6.CMS（Concurrent Mark Sweep）收集器 
> CMS 是一种以最短停顿时间为目标的收集器，使用CMS并不能达到GC效率最高（总体GC时间最小），但它能尽可能降低GC时服务的停顿时间，这一点对于实时或 者高交互性应用（譬如证券交易）来说至关重要，这类应用对于长时间STW一般是不可容忍的。CMS收集器使用的是标记－清除算法，也就是说它在运行期间会 产生空间碎片，所以虚拟机提供了参数开启CMS收集结束后再进行一次内存压缩。 



> **方法重写**
>
> - 参数列表必须完全与被重写方法的相同；
> - 返回类型必须完全与被重写方法的返回类型相同；
> - 访问权限不能比父类中被重写的方法的访问权限更低。例如：如果父类的一个方法被声明为public，那么在子类中重写该方法就不能声明为protected。
> - 父类的成员方法只能被它的子类重写。
> - 声明为final的方法不能被重写。
> - 声明为static的方法不能被重写，但是能够被再次声明。
> - 子类和父类在同一个包中，那么子类可以重写父类所有方法，除了声明为private和final的方法。
> - 子类和父类不在同一个包中，那么子类只能够重写父类的声明为public和protected的非final方法。
> - 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。但是，重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。
> - 构造方法不能被重写。
> - 如果不能继承一个方法，则不能重写这个方法。
>
> **方法重载**
>
> - 被重载的方法必须改变参数列表(参数个数或类型或顺序不一样)；
> - 被重载的方法可以改变返回类型；
> - 被重载的方法可以改变访问修饰符；
> - 被重载的方法可以声明新的或更广的检查异常；
> - 方法能够在同一个类中或者在一个子类中被重载；
> - 无法以返回值类型作为重载函数的区分标准



**Java是一门支持反射的语言,基于反射为Java提供了丰富的动态性支持，下面关于Java反射的描述，哪些是错误的：(  )**

正确答案: A D F  你的答案: B (错误)

```
Java反射主要涉及的类如Class, Method, Filed,等，他们都在java.lang.reflet包下
通过反射可以动态的实现一个接口，形成一个新的类，并可以用这个类创建对象，调用对象方法
通过反射，可以突破Java语言提供的对象成员、类成员的保护机制，访问一般方式不能访问的成员
Java反射机制提供了字节码修改的技术，可以动态的修剪一个类
Java的反射机制会给内存带来额外的开销。例如对永生堆的要求比不通过反射要求的更多
Java反射机制一般会带来效率问题，效率问题主要发生在查找类的方法和字段对象，因此通过缓存需要反射类的字段和方法就能达到与之间调用类的方法和访问类的字段一样的效率
```

> A Class类在java.lang包
>
> B 动态代理技术可以动态创建一个代理对象，反射不行
>
> C 反射访问私有成员时，Field调用setAccessible可解除访问符限制
>
> D CGLIB实现了字节码修改，反射不行 (反射的本质就是从字节码中查找，动态获取类的整容结构，包括属性，构造器，动态调用对象的方法，而不是修剪类)
>
> E 反射会动态创建额外的对象，比如每个成员方法只有一个Method对象作为root，他不胡直接暴露给用户。调用时会返回一个Method的包装类
>
> F 反射带来的效率问题主要是动态解析类，JVM没法对反射代码优化。



**下面有关java threadlocal说法正确的有？**

正确答案: A B C D  你的答案: A B C (错误)

```
ThreadLocal存放的值是线程封闭，线程间互斥的，主要用于线程内共享一些数据，避免通过参数来传递
从线程的角度看，每个线程都保持一个对其线程局部变量副本的隐式引用，只要线程是活动的并且 ThreadLocal 实例是可访问的；在线程消失之后，其线程局部实例的所有副本都会被垃圾回收
在Thread类中有一个Map，用于存储每一个线程的变量的副本
对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而ThreadLocal采用了“以空间换时间”的方式
```

> ThreadLocal类用于创建一个线程本地变量
>
> 在Thread中有一个成员变量ThreadLocals，该变量的类型是ThreadLocalMap,也就是一个Map，它的键是threadLocal，值为就是变量的副本。通过ThreadLocal的get()方法可以获取该线程变量的本地副本，在get方法之前要先set,否则就要重写initialValue()方法。
>
> ThreadLocal的使用场景：
>
> ​    数据库连接：在多线程中，如果使用懒汉式的单例模式创建Connection对象，由于该对象是共享的，那么必须要使用同步方法保证线程安全，这样当一个线程在连接数据库时，那么另外一个线程只能等待。这样就造成性能降低。如果改为哪里要连接数据库就来进行连接，那么就会频繁的对数据库进行连接，性能还是不高。这时使用ThreadLocal就可以既可以保证线程安全又可以让性能不会太低。但是ThreadLocal的缺点时占用了较多的空间。

**以下多线程对int型变量x的操作，哪几个不需要进行同步（  ）**

正确答案: D  你的答案: B (错误)

```
x=y;
x++;
++x;
x=1;
```

> A.由于y的值不确定，所以要加锁；
>
> B,C 两个在多线程情况下是必须要加锁的，因为他们是先被读入寄存器，然后再进行+1操作，如果没有加锁，那么可能会出现数据异常；
>
> D 原子操作，所以不需要加锁
>
>   原子性：指该操作不能再继续划分为更小的操作。
>
>   Java中的原子操作包括：   
>
> ​    1、除long和double之外的基本类型的赋值操作
>
> ​    2、所有引用reference的赋值操作
>
> ​    3、java.concurrent.Atomic.* 包中所有类的一切操作

```
亲自测试了一下，类的`final`成员变量必须满足以下其中一个条件
 ``1``、在构造函数中赋值
 ``2``、初始化赋值
```

> 方法的重载：
>
> 方法重载的定义：同一个类或与他的派生类中，方法名相同，而参数列表不同的方法。其中参数列表不同指的是参数的类型，数量，类型的顺序这三种至少有一种不同。
>
> 方法重载与下列无关：
>
> 与返回值类型无关；与访问修饰符无关
>
> 构造方法也可以重载
>
> 方法的重写：
>
> 方法的重写的定义：在继承关系的子类中，定义一个与父类相同的方法
>
> 判断是否重写的方式：在方法之前加上[@](https://www.nowcoder.com/profile/992988) Overri de
>
> 方法重写的特点：
>
> 在继承关系的子类中重写父类的方法
>
> 重写的方法必须方法名相同，参数列表也相同
>
> 重写的方法的返回值类型应该与父类中被重写方法的返回值类型相同或是他的子类类型
>
> 重写的方法的访问权限应该与父类中被重写方法的访问权限相同或高于它的访问权限
>
> 重写的方法不能抛出比父类更加宽泛的异常
>
> 方法重写的注意事项：
>
> 构造方法不能被重写，不要问为什么？因为构造方法名必须和类名相同
>
> private修饰的成员方法不能被重写
>
> static修饰的方法不能被重写
>
> final修饰的方法不能被重写
>
> 当子类重写了父类中的方法后，子类对象调用该方法时调用的是子类重写后的方法



**下面哪些具体实现类可以用于存储键，值对，并且方法调用提供了基本的多线程安全支持：()**

正确答案: A E  你的答案: A C E (错误)

```
java.util.ConcurrentHashMap
java.util.Map
java.util.TreeMap
java.util.SortMap
java.util.Hashtable
java.util.HashMap
```

> 1. 先说HashMap和HashTable的区别
>        最开始的时候 只有HashMap和HashTable，他们最重要的区别就是HashMap不是线程安全的，而HashTable是线程安全的；他们的具体区别如下：
>        ①:他们的继承是不同的，HashMap继承的是 AbstractMap，而HashTable继承的是Dictionary 类；
>        ②:他们存储的键值对有些区别；HashMap的键能有一个为null，而他的值只能有任意多个是null；
>    由于它的键可以是为空的，所以，所以我们不能用get（key）判断是否有这个键，而应该用containsKey（）这个方法来判断是否有这个键；而HashTable中键值对都不能为空；
>        ③:他们的扩容方式是不一样的；HashMap默认的初始大小是16，装载因子是0.75，并且扩容的大小一定是2的指数；而HashTable的默认初始大小是11，扩容的方式是 2*old+1；
>        ④:哈希值的使用是不同的，HashTable的hash值是直接使用对象中的hashCode方法，而HashMap则是重新计算对象的HashCode；并且用与代替求模；
>        ⑤:两个遍历方式的内部实现上不同。
>    Hashtable、HashMap都使用了 Iterator。而由于历史原因，Hashtable还使用了Enumeration的方式 。
>
> 2. 再看CurrentHashMap和HashMap
>
>    ​	上面已经知道HashMap是线程不安全的了，后来在jdk1.5的时候就出来了CurrentHashMap来弥补HashMap的线程不安全的特性；CurrentHashMap，是将HashMap分成了很多个片（一般默认是16片），引入了分段锁的概念，然后对每一片加锁，具体可以理解成一把大的Map分解成N个小的HashTable，根据key.hashCode（）来决定放到哪一个片上；
>
> 3. 三者效率的比较：
>        由于安全机制的原因，HashMap的效率比HashTable，CurrentHashMap的效率高；但是由于CurrentHashMap加锁的高效性,HashTable是整个加锁，他的效率比HashTable高； 总的来说 HashMap>CurrentHashMap>HashTable;

**三元表达式符  条件语句？表达式1：表达式2**

![image-20200712230119341](C:\Users\CYC\AppData\Roaming\Typora\typora-user-images\image-20200712230119341.png)


> 比如表达式
>
> byte a=2;
>
> a=a-10；
>
> 由于10是整型int，因此表达式a-10；将自动转换成int类型，int类型在赋值给byte，会编译错误
>
> byte a=2;
>
> a-=10;
>
> 不会发生编译错误，因为复合运算符是一个带有隐式转换的运算符，将右侧表达式类型自动转换成左侧表达式类型在基本JAVA类型中，如果不明确指定，整数型的默认是什么类型？带小数的默认是什么类型？



**在基本JAVA类型中，如果不明确指定，整数型的默认是什么类型？带小数的默认是什么类型？**

> 整数类型 默认为 int
> 带小数的默认为 double



**Java修饰符的作用范围**

| **名称**         | **说明**                                     | **备注**                             |
| ---------------- | -------------------------------------------- | ------------------------------------ |
| public           | 可以被任何类访问                             |                                      |
| protected        | 可以被同一包中的所有类访问可以被所有子类访问 | 子类没有在同一包中也可以访问         |
| private          | 只能够被 当前类的方法访问                    |                                      |
| 缺省无访问修饰符 | 可以被同一包中的所有类访问                   | 如果子类没有在同一个包中，也不能访问 |

> 算法包括0个或多个输入，1个或多个输出，中间有穷个处理过程。
> 存储结构不属于算法结构
>
> 一个算法应该具有以下五个重要的特征：
>
> ### 有穷性
>
> （Finiteness）
>
> 算法的有穷性是指算法必须能在执行有限个步骤之后终止；
>
> ### 确切性
>
> (Definiteness)
>
> 算法的每一步骤必须有确切的定义；
>
> ### 输入项
>
> (Input)
>
> 一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件；
>
> ### 输出项
>
> (Output)
>
> 一个算法有一个或多个输出，以反映对输入数据加工后的结果。没有输出的算法是毫无意义的；
>
> ### 可行性
>
> (Effectiveness)
>
> 算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成（也称之为有效性）。

> 子类可以继承父类的所有成员方法，但构造方法不属于父类的成员方法，因此父类的构造函数不能被子类继承，只能被显示或隐式的调用

**下列描述正确的是（ ）？**

正确答案: A C  你的答案: A B C (错误)

```
类不可以多继承而接口可以多实现
抽象类自身可以定义成员而接口不可以
抽象类和接口都不能被实例化
一个类可以有多个基类和多个基接口
```

> 1.java支持单继承，却可以实现多个接口。a对d错
> 2.接口没有构造方法，所以不能实例化，抽象类有构造方法，但是不是用来实例化的，是用来初始化的。c对
> 3.抽象类可以定义普通成员变量而接口不可以，但是抽象类和接口都可以定义静态成员变量，只是接口的静态成员变量要用static final public 来修饰。

**final、finally和finalize的区别中，下述说法正确的有？**

正确答案: A B  你的答案: A B C (错误)

```
final用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承。
finally是异常处理语句结构的一部分，表示总是执行。
finalize是Object类的一个方法，在垃圾收集器执行的时候会调用被回收对象的此方法，可以覆盖此方法提供垃圾收集时的其他资源的回收，例如关闭文件等。
引用变量被final修饰之后，不能再指向其他对象，它指向的对象的内容也是不可变的。
```

> **HttpSessionAttributeListener**：可以实现此侦听器接口获取此web应用程序中会话属性列表更改的通知；
>
> **HttpSessionBindingListener**：当该对象从一个会话中被绑定或者解绑时通知该对象，这个对象由HttpSessionBindingEvent对象通知。这可能是servlet程序显式地从会话中解绑定属性的结果，可能是由于会话无效，也可能是由于会话超时；
>
> **HttpSessionObjectListener**：没有该接口API；
>
> **HttpSessionListener**：当web应用程序中的活动会话列表发生更改时通知该接口的实现类，为了接收该通知事件，必须在web应用程序的部署描述符中配置实现类；
>
> **HttpSessionActivationListener**：绑定到会话的对象可以侦听容器事件，通知它们会话将被钝化，会话将被激活。需要一个在虚拟机之间迁移会话或持久会话的容器来通知所有绑定到实现该接口会话的属性

![image-20200715195046050](C:\Users\CYC\AppData\Roaming\Typora\typora-user-images\image-20200715195046050.png)

> java的基本编程单元是类，基本存储单元是变量。

> Socket套接字 
>
> 就是源Ip地址，目标IP地址，源端口号和目标端口号的组合
>
> 服务器端：ServerSocket提供的实例
>
> ServerSocket server= new ServerSocket(端口号)
>
> 客户端：Socket提供的实例
>
> Socket soc=new Socket(ip地址，端口号)

> Java程序初始化顺序：
>
> 1. 父类的静态代码块
> 2. 子类的静态代码块
> 3. 父类的普通代码块
> 4. 父类的构造方法
> 5. 子类的普通代码块
> 6. 子类的构造方法

![img](https://uploadfiles.nowcoder.com/images/20191010/242025553_1570678660647_2A8BFCA92E7F024DFD2F7B0EA602002E)

> input和output指的是对于程序而言。input是从文件读取进来，output是输出到文件。



> **System.out.println((-3)%2);**
>
> **System.out.println(4%3);**
>
> **System.out.println((-3)%(-2));**
>
> **System.out.println(4%(-3));**
>
> -1
>
> 1
> -1
> 1
> 取模运算，余数的符号跟被除数符号相同

> 由于replaceAll方法的第一个参数是一个正则表达式，而"."在正则表达式中表示任何字符，所以会把前面字符串的所有字符都替换成"/"。如果想替换的只是"."，那么久要写成"\\.".

> 第一，记住wait必须要进行异常捕获
>
> 第二，记住调用wait或者notify方法必须采用当前锁调用，即必须采用synchronized中的对象

> count=count++就是先把局部变量表中count的值0放入操作数栈中，然后直接对局部变量表中的count加1，然后再把操作数栈中的0出栈赋值给局部变量表中的count，最终局部变量表中的count值仍为0
>
> count = count++ 原理是 temp = count； count = count+1 ； count = temp；

> 1.首先，需要明白**类的加载顺序**。
>
> (1) 父类静态代码块(包括静态初始化块，静态属性，但不包括静态方法)
>
> (2) 子类静态代码块(包括静态初始化块，静态属性，但不包括静态方法 )
>
> (3) 父类非静态代码块( 包括非静态初始化块，非静态属性 )
>
> (4) 父类构造函数
>
> (5) 子类非静态代码块 ( 包括非静态初始化块，非静态属性 )
>
> (6) 子类构造函数
>
> 其中：类中静态块按照声明顺序执行，并且(1)和(2)不需要调用new类实例的时候就执行了(意思就是在类加载到方法区的时候执行的)
>
> 2.其次，需要理解子类覆盖父类方法的问题，也就是**方法重写实现多态**问题。
>
> Base b = new Sub();**它为多态的一种表现形式，声明是Base,实现是Sub类，** **理解为** **b** **编译时表现为Base类特性，运行时表现为Sub类特性。**
>
> 当子类覆盖了父类的方法后，意思是父类的方法已经被重写，**题中** **父类初始化调用的方法为子类实现的方法，子类实现的方法中调用的baseName为子类中的私有属性。**
>
> 由1.可知，此时只执行到步骤4.,子类非静态代码块和初始化步骤还没有到，子类中的baseName还没有被初始化。所以此时 baseName为空。 所以为null。

![img](https://uploadfiles.nowcoder.com/images/20160818/787709_1471525792085_AB322A66BF8C4D77C58DCBA0353D0B44)

----

**首先结论：**

**（1）int与Integer、new Integer()进行==比较时，结果永远为true**

**（2）Integer与new Integer()\**进行==\**比较时，结果永远为false**

**（3）Integer与Integer\**进行==\**比较时，看范围；在大于等于-128小于等于127的范围内为true，在此范围外为false。**

下面是解析过程：

**1**.Integer与int比较时，Integer会有拆箱的过程，我们可以看看拆箱的代码：

![img](https://uploadfiles.nowcoder.com/images/20191228/337184788_1577516887286_0B86832D919B6B5273CBE29BFC31B22F)

直接返回的就是value，因此int与Integer以及new Integer()进行 ==比较时结果都是true。

**2**.Integer a=n时，如果n大于等于-128小于等于127时，会直接从IntegerCache中取，不在这个范围内，会new一个对象，所以Integer与new Integer进行 ==比较时，结果都是false。

**3**.Integer与Integer比较，需要看范围，如果在-128~127(包含-128，不包含127)范围内，因为都是从IntegerCache中取值，所以相等；若不在这个范围内，则都要去new一个对象，所以结果为false。

> **首先结论：**
>
> **（1）int与Integer、new Integer()进行==比较时，结果永远为true**
>
> **（2）Integer与new Integer()\**进行==\**比较时，结果永远为false**
>
> **（3）Integer与Integer\**进行==\**比较时，看范围；在大于等于-128小于等于127的范围内为true，在此范围外为false。**
>
> 下面是解析过程：
>
> **1**.Integer与int比较时，Integer会有拆箱的过程，我们可以看看拆箱的代码：
>
> ![img](https://uploadfiles.nowcoder.com/images/20191228/337184788_1577516887286_0B86832D919B6B5273CBE29BFC31B22F)
>
> 直接返回的就是value，因此int与Integer以及new Integer()进行 ==比较时结果都是true。
>
> **2**.Integer a=n时，如果n大于等于-128小于等于127时，会直接从IntegerCache中取，不在这个范围内，会new一个对象，所以Integer与new Integer进行 ==比较时，结果都是false。
>
> **3**.Integer与Integer比较，需要看范围，如果在-128~127(包含-128，不包含127)范围内，因为都是从IntegerCache中取值，所以相等；若不在这个范围内，则都要去new一个对象，所以结果为false。



> 声明使用的意思是像：Object s = new String();这里的Object类就被声明使用了，抽象类和接口都可以被声明使用。
>
> 【声明使用】
> TestInterface ti=new TestInterface() {
> //在TestInterface中抽象方法show(),所以声明使用的时候要加上其抽象方法的实现
> @Override
> public String show() {
> // TODO Auto-generated method stub
> return null;
> }
> };



> 可以把任何一种数据类型的变量赋给Object类型的变量，因为java所有类默认继承Object，基本数据类型赋值给Object会先装箱，装箱之后就是Object的子类了；

> substring后面跟的两个int值的索引下标是一个左闭右开的集合。包含左边的，不包含右边的

~~~
补充Java内存管理知识：

1. 内存分配策略

按照编译原理的观点，程序运行时的内存分配有三种策略，分别是静态的,栈式的,和堆式的。

静态存储分配是指在编译时就能确定每个数据目标在运行时刻的存储空间需求，因而在编译时就可以给他们分配固定的内存空间。这种分配策略要求程序代码中不允许有可变数据结构(比如可变数组)的存在，也不允许有嵌套或者递归的结构出现,因为它们都会导致编译程序无法计算准确的存储空间需求。

栈式存储分配也可称为动态存储分配，是由一个类似于堆栈的运行栈来实现的。和静态存储分配相反，在栈式存储方案中，程序对数据区的需求在编译时是完全未知的，只有到运行的时候才能够知道，但是规定在运行中进入一个程序模块时，必须知道该程序模块所需的数据区大小才能够为其分配内存。和我们在数据结构所熟知的栈一样，栈式存储分配按照先进后出的原则进行分配。

静态存储分配要求在编译时能知道所有变量的存储要求，栈式存储分配要求在过程的入口处必须知道所有的存储要求，而堆式存储分配则专门负责在编译时或运行时模块入口处都无法确定存储要求的数据结构的内存分配，比如可变长度串和对象实例。堆由大片的可利用块或空闲块组成，堆中的内存可以按照任意顺序分配和释放。

2. JVM中的堆和栈

JVM是基于堆栈的虚拟机。JVM为每个新创建的线程都分配一个堆栈，也就是说，对于一个Java程序来说，它的运行就是通过对堆栈的操作来完成的。堆栈以帧为单位保存线程的状态。JVM对堆栈只进行两种操作:以帧为单位的压栈和出栈操作。

java把内存分两种：一种是栈内存，另一种是堆内存

栈(stack)与堆(heap)都是Java用来在Ram中存放数据的地方。与C++不同，Java自动管理栈和堆，程序员不能直接地设置栈或堆。

栈(stack)：是一个先进后出的数据结构,通常用于保存方法(函数)中的参数，局部变量。

堆(heap)：是一个可动态申请的内存空间(其记录空闲内存空间的链表由操作系统维护)，是一个运行时数据区，C中的malloc语句所产生的内存空间就在堆中。

3. 堆和栈优缺点比较

栈的优势是，存取速度比堆要快，仅次于直接位于CPU中的寄存器。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。另外，栈数据可以共享，详见第3点。

堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，Java的垃圾收集器会自动收走这些不再使用的数据。但缺点是，由于要在运行时动态分配内存，存取速度较慢。

4. Java中的数据类型有两种

一种是基本类型

共有8种，即int, short, long, byte, float, double, boolean, char(注意，并没有string的基本类型)。

这种类型的定义是通过诸如int a = 3; long b = 255L;的形式来定义的，称为自动变量。值得注意的是，自动变量存的是字面值，不是类的实例，即不是类的引用，这里并没有类的存在。如int a = 3; 这里的a是一个指向int类型的引用，指向3这个字面值。这些字面值的数据，由于大小可知，生存期可知(这些字面值固定定义在某个程序块里面，程序块退出后，字段值就消失了)，出于追求速度的原因，就存在于栈中。

另外，栈有一个很重要的特殊性，就是存在栈中的数据可以共享。假设我们同时定义：

int a = 3;
int b = 3；
编译器先处理int a = 3；首先它会在栈中创建一个变量为a的引用，然后查找有没有字面值为3的地址，没找到，就开辟一个存放3这个字面值的地址，然后将a指向3的地址。接着处理int b = 3；在创建完b的引用变量后，由于在栈中已经有3这个字面值，便将b直接指向3的地址。这样，就出现了a与b同时均指向3的情况。

特别注意的是，这种字面值的引用与类对象的引用不同。假定两个类对象的引用同时指向一个对象，如果一个对象引用变量修改了这个对象的内部状态，那么另一个对象引用变量也即刻反映出这个变化。相反，通过字面值的引用来修改其值，不会导致另一个指向此字面值的引用的值也跟着改变的情况。如上例，我们定义完a与b的值后，再令a=4；那么，b不会等于4，还是等于3。在编译器内部，遇到a=4；时，它就会重新搜索栈中是否有4的字面值，如果没有，重新开辟地址存放4的值；如果已经有了，则直接将a指向这个地址。因此a值的改变不会影响到b的值。

另一种是包装类数据

如Integer, String, Double等将相应的基本数据类型包装起来的类。这些类数据全部存在于堆中，Java用new()语句来显示地告诉编译器，在运行时才根据需要动态创建，因此比较灵活，但缺点是要占用更多的时间。

String是一个特殊的包装类数据。即可以用String str = new String(“abc”);的形式来创建，也可以用String str = “abc”；的形式来创建(作为对比，在JDK 5.0之前，你从未见过Integer i = 3;的表达式，因为类与字面值是不能通用的，除了String。而在JDK 5.0中，这种表达式是可以的！因为编译器在后台进行Integer i = new Integer(3)的转换)。前者是规范的类的创建过程，即在Java中，一切都是对象，而对象是类的实例，全部通过new()的形式来创建。Java中的有些类，如DateFormat类，可以通过该类的getInstance()方法来返回一个新创建的类，似乎违反了此原则。其实不然。该类运用了单例模式来返回类的实例，只不过这个实例是在该类内部通过new()来创建的，而getInstance()向外部隐藏了此细节。那为什么在String str = “abc”；中，并没有通过new()来创建实例，是不是违反了上述原则？其实没有。

 5．String在内存中的存放

String是一个特殊的包装类数据，可以用用以下两种方式创建：

String str = new String(“abc”)；第一种创建方式是用new()来新建对象的，它会存放于堆中。每调用一次就会创建一个新的对象。

String str = “abc”;  第二种创建方式先在栈中创建一个对String类的对象引用变量str，然后在栈中查找有没有存放值为”abc”的地址，如果没有，则开辟一个存放字面值为”abc”的地址，接着创建一个新的String类的对象o，并将o的字符串值指向这个地址，而且在栈中这个地址旁边记下这个引用的对象o。如果已经有了值为”abc”的地址，则查找对象o，并返回o的地址,最后将str指向对象o的地址。

值得注意的是，一般String类中字符串值都是直接存值的。但像String str = “abc”；这种场合下，其字符串值却是保存了一个指向存在栈中数据的引用！

6.数组在内存中的存放

int x[] 或者int []x 时，在内存栈空间中创建一个数组引用，通过该数组名来引用数组。

x = new int[5] 将在堆内存中分配5个保存int型数据的空间，堆内存的首地址放到栈内存中，每个数组元素被初始化为0。

7.static变量在内存中的存放

用 static的修饰的变量和方法，实际上是指定了这些变量和方法在内存中的“固定位置”－static storage。既然要有“固定位置”那么他们的 “大小”似乎就是固定的了，有了固定位置和固定大小的特征了，在栈中或堆中开辟空间那就是非常的方便了。如果静态的变量或方法在不出其作用域的情况下，其引用句柄是不会发生改变的。

8. java中变量在内存中的分配

1、类变量（static修饰的变量）

在程序加载时系统就为它在堆中开辟了内存，堆中的内存地址存放于栈以便于高速访问。静态变量的生命周期一直持续到整个”系统”关闭

2、实例变量

当你使用java关键字new的时候，系统在堆中开辟并不一定是连续的空间分配给变量（比如说类实例），然后根据零散的堆内存地址，通过哈希算法换算为一长串数字以表征这个变量在堆中的”物理位置”。 实例变量的生命周期–当实例变量的引用丢失后，将被GC（垃圾回收器）列入可回收“名单”中，但并不是马上就释放堆中内存

3、局部变量

局部变量，由声明在某方法，或某代码段里（比如for循环），执行到它的时候在栈中开辟内存，当局部变量一但脱离作用域，内存立即释放
~~~

~~~
Maven和Ant的区别
	Ant和Maven都是基于Java的构建(build)工具。理论上来说，有些类似于（Unix）C中的make ，但没有make的缺陷。Ant是软件构建工具，Maven的定位是软件项目管理和理解工具。
Ant特点 
没有一个约定的目录结构 必须明确让ant做什么，什么时候做，然后编译，打包 没有生命周期，必须定义目标及其实现的任务序列 没有集成依赖管理
Maven特点
拥有约定，知道你的代码在哪里，放到哪里去 拥有一个生命周期，例如执行 mvn install 就可以自动执行编译，测试，打包等构建过程 只需要定义一个pom.xml,然后把源码放到默认的目录，Maven帮你处理其他事情 拥有依赖管理，仓库管理
~~~

设有下面两个赋值语句：

a = Integer.parseInt("1024");

b = Integer.valueOf("1024").intValue();

下述说法正确的是（）

**正确答案: D  你的答案: A (错误)**

```
a是整数类型变量，b是整数类对象。
a是整数类对象，b是整数类型变量。
a和b都是整数类对象并且它们的值相等。
a和b都是整数类型变量并且它们的值相等。
```

> intValue()是把Integer对象类型变成int的基础数据类型；
> parseInt()是把String 变成int的基础数据类型；
> Valueof()是把String 转化成Integer对象类型；（现在JDK版本支持自动装箱拆箱了。）

> 按照流是否直接与特定的地方（如磁盘、内存、设备等）相连，分为节点流和处理流两类。
>
> - 节点流：可以从或向一个特定的地方（节点）读写数据。如FileReader.
> - 处理流：是对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写。如BufferedReader.处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。
>
> **JAVA常用的节点流：**
>
> - 文 件 FileInputStream FileOutputStrean FileReader FileWriter 文件进行处理的节点流。
> - 字符串 StringReader StringWriter 对字符串进行处理的节点流。
> - 数 组 ByteArrayInputStream ByteArrayOutputStreamCharArrayReader CharArrayWriter 对数组进行处理的节点流（对应的不再是文件，而是内存中的一个数组）。
> - 管 道 PipedInputStream PipedOutputStream PipedReaderPipedWriter对管道进行处理的节点流。
>
> **常用处理流（关闭处理流使用关闭里面的节点流）**
>
> - 缓冲流：BufferedInputStrean BufferedOutputStream BufferedReader BufferedWriter 增加缓冲功能，避免频繁读写硬盘。
>
> - 转换流：InputStreamReader OutputStreamReader 实现字节流和字符流之间的转换。
> - 数据流 DataInputStream DataOutputStream 等-提供将基础数据类型写入到文件中，或者读取出来.
>
> ### 流的关闭顺序
>
> 1. 一般情况下是：先打开的后关闭，后打开的先关闭
> 2. 另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b
> 3. 可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法。

> 1、强引用：一个对象赋给一个引用就是强引用，比如new一个对象，一个对象被赋值一个对象。
>
> 2、软引用：用SoftReference类实现，一般不会轻易回收，只有内存不够才会回收。
>
> 3、弱引用：用WeekReference类实现，一旦垃圾回收已启动，就会回收。
>
> 4、虚引用：不能单独存在，必须和引用队列联合使用。主要作用是跟踪对象被回收的状态。

~~~
当运算符“+”在字符串类型数据中，它就成了用于连接字符串的特殊的运算
当“+”用在表达式中，如果有一个操作数是字符串类型，Java会自动将另一个字符串转换成字符串，然后将这两个字符串相连组成一个新的字符串
~~~

~~~
fseek
函数原型：int fseek(FILE *stream,long offset,int framewhere)
作用：重定位文件内部的指针
fread
函数原型:size_t fread(void* buff,size_t size,size_t count,FILE* stream)
作用：从文件中读入数据到指定的地址中
fopen
fopen函数是在当前目录下打开一个文件，其调用的一般形式为：
文件指针名=fopen（文件名,使用文件方式）;
fopen
读写字符串函数
~~~

~~~
Java运行时的数据区包括：（其中前两个是线程共享的）
1.方法区（Method Area） 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
2.堆（Heap） 存放对象实例，几乎所有对象实例都在这里分配内存
3.虚拟机栈（VM Stack） 描述的是Java方法执行的内存模型：每个方法在执行的同时会创建一个Stack Frame（方法运行时的基础数据结构）用于存储局部变量表、操作数栈、动态连接、方法出口等信息
4.本地方法栈（Native Method Stack）  与虚拟机栈了类似，不过则为虚拟机使用的到的Native方法服务。（有的虚拟机譬如Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一）
5.程序计数器（Program Counter Register） 可看作当前线程所执行的字节码的行号的标识器
~~~

~~~
servlet在多线程下其本身并不是线程安全的。
如果在类中定义成员变量，而在service中根据不同的线程对该成员变量进行更改，那么在并发的时候就会引起错误。最好是在方法中，定义局部变量，而不是类变量或者对象的成员变量。由于方法中的局部变量是在栈中，彼此各自都拥有独立的运行空间而不会互相干扰，因此才做到线程安全。
~~~

---

```
Integer i = ``42``;
Long l = 42l;
Double d = ``42.0``;
```

下面为true的是

**正确答案: G  你的答案: F (错误)**

```
(i == l)
(i == d)
(l == d)
i.equals(d)
d.equals(l)
i.equals(l)
l.equals(42L)
```

> 包装类的“==”运算在不遇到算术运算的情况下不会自动拆箱
>
> 包装类的equals()方法不处理数据转型

~~~
1、基本型和基本型封装型进行“==”运算符的比较，基本型封装型将会自动拆箱变为基本型后再进行比较，因此Integer(0)会自动拆箱为int类型再进行比较，显然返回true；

         int a = 220;

         Integer b = 220;

        System.out.println(a==b);//true
2、两个Integer类型进行“==”比较， 如果其值在-128至127  ，那么返回true，否则返回false, 这跟Integer.valueOf()的缓冲对象有关，这里不进行赘述。

        Integer c=3;
        Integer h=3;
        Integer e=321;
        Integer f=321;
        System.out.println(c==h);//true
        System.out.println(e==f);//false
3、两个基本型的封装型进行equals()比较，首先equals()会比较类型，如果类型相同，则继续比较值，如果值也相同，返回true。

        Integer a=1;
        Integer b=2;
        Integer c=3;
        System.out.println(c.equals(a+b));//true
4、基本型封装类型调用equals(),但是参数是基本类型，这时候，先会进行自动装箱，基本型转换为其封装类型，再进行3中的比较。 

        int i=1;
        int j = 2;
        Integer c=3;
        System.out.println(c.equals(i+j));//true
~~~

**Servlet与JSP九大内置对象的关系**

> JSP对象 怎样获得
>
> out->response.getWriter
>
> request ->Service方法中的req参数
>
> response ->Service方法中的resp参数
>
> session ->request.getSession
>
> application ->getServletContext
>
> exception ->Throwable
>
> page  ->this
>
> pageContext  ->PageContext
>
> Config ->getServletConfig

---

**下面是直接总结的，有个地方写错了Hashtable的默认长度是11不是16。**

![img](https://uploadfiles.nowcoder.com/images/20180713/3807435_1531452714386_2F9D3C66E590BF58A97946A6D68650EE)

---

![img](https://uploadfiles.nowcoder.com/images/20180701/3807435_1530425536125_D49BCBCCF82CF58C566E12F1E3130070)

> 栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中
>
> 堆：存放用new产生的数据
>
> 静态域：存放在对象中用static定义的静态成员
>
> 常量池：存放常量
>
> 非RAM存储：硬盘等永久存储空间

> 垃圾收集机制：新生代、老年代、持久代
>
> ![img](https://uploadfiles.nowcoder.com/images/20180411/7172803_1523440475066_2AA6D19E6A170E0E245A561A593D035E)
>
> 1，新生代：（1）所有对象创建在新生代的Eden区，当Eden区满后触发新生代的Minor GC，将Eden区和非空闲Survivor区存活的对象复制到另外一个空闲的Survivor区中。（2）保证一个Survivor区是空的，新生代Minor GC就是在两个Survivor区之间相互复制存活对象，直到Survivor区满为止。
>
> 2，老年代：当Survivor区也满了之后就通过Minor GC将对象复制到老年代。老年代也满了的话，就将触发Full GC，针对整个堆（包括新生代、老年代、持久代）进行垃圾回收。
>
> 3，持久代：持久代如果满了，将触发Full GC

---

![img](http://uploadfiles.nowcoder.com/images/20160129/828061_1454054455847_8A5F006FFD4CE801C8E888EC3BC68361)

> **goto和const**是保留字也是关键字。
>
> 1，Java **关键字**列表 (依字母排序 共50组)：
>
> abstract, assert, boolean, break, byte, case, catch, char, class, **const**（保留关键字）, continue, default, do, double, else, enum, extends, final, finally, float, for, **goto**（保留关键字）, if, implements, import, instanceof, int, interface, long, native, new, package, private, protected, public, return, short, static, strictfp, super, switch, synchronized, this, throw, throws, transient, try, void, volatile, while
>
> 2，**保留字**列表 (依字母排序 共14组)，Java保留字是指现有Java版本尚未使用，但以后版本可能会作为关键字使用：
>
> byValue, cast, **false**, future, generic, inner, operator, outer, rest, **true**, var, **goto** （保留关键字） , **const** （保留关键字） , **null**

> **System是java.lang中的类，out为System中的一个静态成员，out是****java.io.PrintStream类的对象，而println()是****java.io.PrintStream类的方法，所有可以调用类.静态方法.println()方法。**

> 传值传参的时候，我们在函数中改变了参数的值，其对应的变量的值并不改变，值类型传参就是将变量保存的内容复制到函数的形参中，他们是两个不同的变量，值不过保存的内容相同不了.
>
> 引用传参保存的是一个地址，这个地址里保存的是变量的具体值，而引用类型作为参数的时候，是将变量保存的地址值赋值到参数变量里，这样他们都指向了同一个内容，这样我们改变参数的成员的话，那么相应的变量的成员也会改变。

----

```
关键字``volatile``是线程同步的轻量级实现，所以``volatile``性能肯定比``synchronized``要好，并且只能修改变量，而``synchronized``可以修饰方法，以及代码块。
  
```

```
  
    ``多线程访问``volatile``不会发生阻塞，而``synchronized``会出现阻塞
  
```

```
  
    ``volatile``能保证数据的可见性，但不能保证原子性；而``synchronized``可以保证原子性，也可以间接保证可见性，因为它会将私有内存和公共内存中的数据做同步
  
```

```
  
    ``关键字``volatile``解决的下变量在多线程之间的可见性；而``synchronized``解决的是多线程之间资源同步问题
```

> java,exe是java虚拟机
>
> javadoc.exe用来制作java文档
>
> jdb.exe是java的调试器
>
> javaprof,exe是剖析工具

> Servlet的生命周期分为5个阶段：加载、创建、初始化、处理客户请求、卸载。
>
> (1)加载：容器通过类加载器使用servlet类对应的文件加载servlet
>
> (2)创建：通过调用servlet构造函数创建一个servlet对象,创建Servlet的实例是由Servlet容器来完成的，且创建Servlet实例是在初始化方法init()之前
>
> (3)初始化：调用init方法初始化
>
> (4)处理客户请求：每当有一个客户请求，容器会创建一个线程来处理客户请求
>
> (5)卸载：调用destroy方法让servlet自己释放其占用的资源

> 抽象类可以有构造函数，但不能实例化

> **Java** **中的堆是** **JVM** **所管理的最**大的一块内存空间，主要用于存放各种类的实例对象。
>
> 在 **Java** 中，堆被划分成两个不同的区域：新生代 ( Young )、老年代 ( Old )。新生代 ( Young ) 又被划分为三个区域：Eden、From Survivor、To Survivor。
> 这样划分的目的是为了使 **JVM** 能够更好的管理堆内存中的对象，包括内存的分配以及回收。
> 堆的内存模型大致为：
>
> ![img](http://www.blogjava.net/images/blogjava_net/fancydeepin/JVM/%E5%A0%86%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B2.png)
>
> 从图中可以看出： 堆大小 = 新生代 + 老年代。其中，堆的大小可以通过参数 –Xms、-Xmx 来指定。
> 本人使用的是 JDK1.6，以下涉及的 **JVM** 默认值均以该版本为准。
> 默认的，新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 )，即：新生代 ( Young ) = 1/3 的堆空间大小。
> 老年代 ( Old ) = 2/3 的堆空间大小。其中，新生代 ( Young ) 被细分为 Eden 和 两个 Survivor 区域，这两个 Survivor 区域分别被命名为 from 和 to，以示区分。
> 默认的，Edem : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。
> **JVM** 每次只会使用 Eden 和其中的一块 Survivor 区域来为对象服务，所以无论什么时候，总是有一块 Survivor 区域是空闲着的。
> 因此，新生代实际可用的内存空间为 9/10 ( 即90% )的新生代空间。

> 低级向高级是隐式类型转换，高级向低级必须强制类型转换，byte<char<short<int<long<float<double

> 枚举类 所有的枚举值都是类静态常量，在初始化时会对所有的枚举值对象进行第一次初始化	
>
> 枚举类有三个实例，故调用三次构造方法

> Java标识符由 **数字、字母、下划线(_)、美元符号($)** 组成， **首位不能是数字** 。并且 **Java关键字不能作为标识符** 

> 线程安全的map:**HashTable,\**SynchronizedMap,\*\*ConcurrentHashMap\*\**\***

- Hashtable是线程安全的哈希表，它是通过synchronized来保证线程安全的；即，多线程通过同一个“对象的同步锁”来实现并发控制。Hashtable在线程竞争激烈时，效率比较低（此时建议使用ConcurrentHashMap）。当一个线程访问Hashtable的同步方法时，其它线程如果也在访问Hashtable的同步方法时，可能会进入阻塞状态。

- Collections.synchronizedMap()使用了synchronized同步关键字来保证对Map的操作是线程安全的。

- ConcurrentHashMap是线程安全的哈希表。在JDK1.7中它是通过“锁分段”来保证线程安全的，本质上也是一个“可重入的互斥锁”（ReentrantLock）。多线程对同一个片段的访问，是互斥的；但是，对于不同片段的访问，却是可以同步进行的。在JDK1.8中是通过使用CAS原子更新、volatile关键字、synchronized可重入锁实现的。

> 两个数值进行二元操作时，会有如下的转换操作：
>
> 如果两个操作数其中有一个是double类型，另一个操作就会转换为double类型。
>
> 否则，如果其中一个操作数是float类型，另一个将会转换为float类型。
>
> 否则，如果其中一个操作数是long类型，另一个会转换为long类型。
>
> 否则，两个操作数都转换为int类型。

> **字节流：**
>
> InputStream
> |-- FileInputStream (基本文件流）
> |-- BufferedInputStream
> |-- DataInputStream
>
> |-- ObjectInputStream
>
> **字符流**
>
> Reader
> |-- InputStreamReader (byte->char 桥梁）
> |-- BufferedReader (常用）
> Writer
> |-- OutputStreamWriter (char->byte 桥梁）
> |-- BufferedWriter
> |-- PrintWriter （常用）
>
> 
>
> ![img](https://uploadfiles.nowcoder.com/images/20190802/817945927_1564705878247_848D64C7FAB5E984961D97FD8B3D21A8)

---

~~~
Java表达式转型规则由低到高转换：
1、所有的byte,short,char型的值将被提升为int型；
2、如果有一个操作数是long型，计算结果是long型；

3、如果有一个操作数是float型，计算结果是float型；

4、如果有一个操作数是double型，计算结果是double型；
5、被fianl修饰的变量不会自动改变类型，当2个final修饰相操作时，结果会根据左边变量的类型而转化。
~~~

> A、java中类的加载有5个过程，加载、验证、准备、解析、初始化；这便是类加载的5个过程，而类加载器的任务是根据一个类的全限定名来读取此类的二进制字节流到JVM中，然后转换为一个与目标类对应的java.lang.Class对象实例，在虚拟机提供了3种类加载器，引导（Bootstrap）类加载器、扩展（Extension）类加载器、系统（System）类加载器（也称应用类加载器）。A正确
>
> B、一个类，由不同的类加载器实例加载的话，会在方法区产生两个不同的类，彼此不可见，并且在堆中生成不同Class实例。所以B前面部分是正确的，后面接口的部分真的没有尝试过，等一个大佬的讲解吧；
>
> C、类加载器是肯定要保证线程安全的；C正确
>
> D、装载一个不存在的类的时候，因为采用的双亲加载模式，所以强制加载会直接报错，D错误
>
> java.lang.SecurityException: Prohibited package name: java.lang
>
> E、双亲委派模式是在Java 1.2后引入的，其工作原理的是，如果一个类加载器收到了类加载请求，它并不会自己先去加载，而是把这个请求委托给父类的加载器去执行，如果父类加载器还存在其父类加载器，则进一步向上委托，依次递归，请求最终将到达顶层的启动类加载器，如果父类加载器可以完成类加载任务，就成功返回，倘若父类加载器无法完成此加载任务，子加载器才会尝试自己去加载，这就是双亲委派模式，即每个儿子都很懒，每次有活就丢给父亲去干，直到父亲说这件事我也干不了时，儿子自己想办法去完成，所以默认是父装载，E正确
>
> F、自定义类加载器实现 继承ClassLoader后重写了findClass方法加载指定路径上的class

> 常见的代码优化技术有：复写传播，删除死代码, 强度削弱，归纳变量删除,代码外提

> C语言中
>
> 当if语句中的条件为赋值语句时，实际上是将赋值后的结果与0进行比较【左值】
>
> if（1）  由于1>0  所以认为是true
>
> java语言中，虽然也用了左值，但是不再与0比较，而是直接将0放入if()中
>
> 但是int类型，不能转换为boolean，所以会报错：“ Type mismatch: cannot convert from int to boolean ”
>
> 
>
>  c语言跟java不一样，c非0为真，而java并不是这样。

---

JVM内存五大区域

![img](https://uploadfiles.nowcoder.com/images/20190606/291053_1559812298987_4E467FB794A7AF7967F62555B4F0B6A6)

> 定义在类中的变量是类的成员变量，可以不进行初始化，Java会自动进行初始化，如果是引用类型默认初始化为null,如果是基本类型例如int则会默认初始化为0
>
> **局部变量是定义在方法中的变量，必须要进行初始化，否则不同通过编译**
>
> 被static关键字修饰的变量是静态的，静态变量随着类的加载而加载，所以也被称为类变量
>
> 被final修饰发变量是常量

> switch语句后的控制表达式只能是short、char、int、long整数类型和枚举类型，不能是float，double和boolean类型。**String类型是java7开始支持。**

> Java体系结构包括四个独立但相关的技术：
>
> - Java程序设计语言
> - Java.class文件格式
> - Java应用编程接口（API）
> - Java虚拟机
>
> 我们再在看一下它们四者的关系：
>
>   当我们编写并运行一个Java程序时，就同时运用了这四种技术，用**Java程序设计语言**编写源代码，把它编译成**Java.class文件格式**，然后再在**Java虚拟机中运行class文件**。当程序运行的时候，它通过调用class文件实现了**Java API的方法**来满足程序的Java API调用

~~~
普通的java对象是通过new关键字把对应类的字节码文件加载到内存，然后创建该对象的。
反射是通过一个名为Class的特殊类，用Class.forName("className");得到类的字节码对象，然后用newInstance()方法在虚拟机内部构造这个对象（针对无参构造函数）。
也就是说反射机制让我们可以先拿到java类对应的字节码对象，然后动态的进行任何可能的操作，
包括
在运行时判断任意一个对象所属的类
在运行时构造任意一个类的对象
在运行时判断任意一个类所具有的成员变量和方法
在运行时调用任意一个对象的方法
这些都是反射的功能。
使用反射的主要作用是方便程序的扩展。
~~~

> STL库中，map和multimap底层都是红黑树实现的，两者的不同在于multimap允许重复的可以，而map中不行。
>
> 红黑树的查找复杂度为O(log(n))
>
> unodered_map/_set底层是哈希表实现的，查找复杂度为O(1)

~~~
线程的一些方法：
1.sleep()方法

在指定时间内让当前正在执行的线程暂停执行，但不会释放“锁标志”。不推荐使用。

sleep()使当前线程进入阻塞状态，在指定时间内不会执行。

2.wait()方法

在其他线程调用对象的notify或notifyAll方法前，导致当前线程等待。线程会释放掉它所占有的“锁标志”，从而使别的线程有机会抢占该锁。

当前线程必须拥有当前对象锁。如果当前线程不是此锁的拥有者，会抛出IllegalMonitorStateException异常。

唤醒当前对象锁的等待线程使用notify或notifyAll方法，也必须拥有相同的对象锁，否则也会抛出IllegalMonitorStateException异常。

waite()和notify()必须在synchronized函数或synchronized　block中进行调用。如果在non-synchronized函数或non-synchronized　block中进行调用，虽然能编译通过，但在运行时会发生IllegalMonitorStateException的异常。

3.yield方法

暂停当前正在执行的线程对象。

yield()只是使当前线程重新回到可执行状态，所以执行yield()的线程有可能在进入到可执行状态后马上又被执行。

yield()只能使同优先级或更高优先级的线程有执行的机会。 

        4.join方法
join()等待该线程终止。
等待调用join方法的线程结束，再继续执行。如：t.join();//主要用于等待t线程运行结束，若无此句，main则会执行完毕，导致结果不可预测
~~~

