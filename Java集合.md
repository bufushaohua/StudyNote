## Java集合

### 集合容器概述

#### 什么是集合

**集合框架**：用于存储数据的容器。

- 集合框架是为表示和操作集合而规定的一种统一的标准的体系结构。

- 任何集合框架都包含三大块内容：对外的接口、接口的实现和对集合运算的算法。

**接口**：表示集合的抽象数据类型。接口允许我们操作集合时不必关注具体实现，从而达到“多态”。在面向对象编程语言中，接口通常用来形成规范。

**实现**：集合接口的具体实现，是重用性很高的数据结构。

**算法**：在一个实现了某个集合框架中的接口的对象身上完成某种有用的计算的方法，例如查找、排序等。这些算法通常是多态的，因为相同的方法可以在同一个接口被多个类实现时有不同的表现。事实上，算法是可复用的函数。
它减少了程序设计的辛劳。

>  集合框架通过提供有用的数据结构和算法使你能集中注意力于你的程序的重要部分上，而不是为了让程序能正常运转而将注意力于低层设计上。
> 通过这些在无关API之间的简易的互用性，使你免除了为改编对象或转换代码以便联合这些API而去写大量的代码。 它提高了程序速度和质量。

#### 集合的特点

集合的特点主要有如下两点：

- 对象封装数据，对象多了也需要存储。集合用于存储对象。

- 对象的个数确定可以使用数组，对象的个数不确定的可以用集合。因为集合是可变长度的。

#### 集合和数组的区别

|                  | 集合                             | 数组                                   |
| :--------------: | -------------------------------- | -------------------------------------- |
|     长度可变     | 集合长度可变                     | 数组长度固定                           |
|   存储数据类型   | 集合只能是引用类型               | 数据既可以是引用类型，也可以是基本类型 |
| 数据类型是否统一 | 集合存储的对象可以是不同数据类型 | 数组存储的元素必须是同一个数据类型     |

### 常用的集合类有哪些？

Map接口和Collection接口是所有集合框架的父接口：

- Collection接口的子接口包括：Set接口和List接口
- Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等
- Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等
- List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等

![image-20200524151558951](C:\Users\CYC\AppData\Roaming\Typora\typora-user-images\image-20200524151558951.png)

==Java 容器分为 Collection 和 Map 两大类==，Collection集合的子接口有Set、List、Queue三种子接口。我们比较常用的是Set、List，Map接口不是collection的子接口。

`Collection`集合主要有List和Set两大接口

- `List`：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。
- `Set`：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。
- `Map`是一个键值对集合，存储键、值和之间的映射。 Key无序，唯一；value 不要求有序，允许重复。Map没有继承于Collection接口，从Map集合中检索元素时，只要给出键对象，就会返回对应的值对象。

Map 的常用实现类：`HashMap`、`TreeMap`、`HashTable`、`LinkedHashMap`、`ConcurrentHashMap`



#### Collection类(接口)

[:point_down:所有方法]()

| `方法返回类型`             | `方法名及描述`           |
| ------------------------ | ------------------------------------------------------------ |
| `boolean`                | `add(E e)`  确保此集合包含指定的元素（可选操作）。           |
| `boolean`                | `addAll(Collection<? extends E> c)`  将指定集合中的所有元素添加到此集合（可选操作）。 |
| `void`                   | `clear()`  从此集合中删除所有元素（可选操作）。              |
| `boolean`                | `contains(Object o)`  如果此集合包含指定的元素，则返回 `true` 。 |
| `boolean`                | `containsAll(Collection<?> c)`  如果此集合包含指定 `集合`中的所有元素，则返回true。 |
| `boolean`                | `equals(Object o)`  将指定的对象与此集合进行比较以获得相等性。 |
| `int`                    | `hashCode()`  返回此集合的哈希码值。                         |
| `boolean`                | `isEmpty()`  如果此集合不包含元素，则返回 `true` 。          |
| `Iterator<E>`            | `iterator()`  返回此集合中的元素的迭代器。                   |
| `default Stream<E>`      | `parallelStream()`  返回可能并行的 `Stream`与此集合作为其来源。 |
| `boolean`                | `remove(Object o)`  从该集合中删除指定元素的单个实例（如果存在）（可选操作）。 |
| `boolean`                | `removeAll(Collection<?> c)`  删除指定集合中包含的所有此集合的元素（可选操作）。 |
| `default boolean`        | `removeIf(Predicate<? super E> filter)`  删除满足给定谓词的此集合的所有元素。 |
| `boolean`                | `retainAll(Collection<?> c)`  仅保留此集合中包含在指定集合中的元素（可选操作）。 |
| `int`                    | `size()`  返回此集合中的元素数。                             |
| `default Spliterator<E>` | `spliterator()`  创建一个[`Spliterator`](../../java/util/Spliterator.html)在这个集合中的元素。 |
| `default Stream<E>`      | `stream()`  返回以此集合作为源的顺序 `Stream` 。             |
| `Object[]`               | `toArray()`  返回一个包含此集合中所有元素的数组。            |
| `<T> T[]`                | `toArray(T[] a)`  返回包含此集合中所有元素的数组;  返回的数组的运行时类型是指定数组的运行时类型。 |



#### ArrayList 和 LinkedList 的区别是什么？

|              | ArrayList      | LinkedList     |
| ------------ | -------------- | -------------- |
| 数据结构     | 由动态数组实现 | 由双向链表实现 |
| 随机访问效率 | 高 |低，因为 LinkedList 是线性的数据存储方式，所以需要移动指针从前往后依次查找|
| 增加和删除效率 | 在非首尾的增加和删除操作，低，因为 ArrayList 增删操作要影响数组内的其他数据的下标。 | 高 |
| 内存空间占用 | 少 | 多，因为 LinkedList 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。 |
| 线程安全 | 不保证线程安全 | 不保证线程安全 |

> 综合来说，在需要频繁读取集合中的元素时，更推荐使用 ArrayList，而在插入和删除操作较多时，更推荐使用 LinkedList。

#### ArrayList 和 Vector 的区别是什么？

这两个类都实现了 List 接口（List 接口继承了 Collection 接口），他们都是有序集合

- **线程安全**：Vector 使用了 Synchronized 来实现线程同步，是线程安全的，而 ArrayList 是非线程安全的。
- **性能**：ArrayList 在性能方面要优于 Vector。Vector类的所有方法都是同步的，并且一个线程访问Vector的话代码要在同步操作上耗费大量的时间。
- **扩容**：ArrayList 和 Vector 都会根据实际的需要动态的调整容量，只不过在 Vector 扩容每次会增加 1 倍，而 ArrayList 只会增加 50%。

> Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。
>
> Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。

#### List 和 Set 的区别

List , Set 都是继承自Collection 接口

**List 特点**：一个有序（元素存入集合的顺序和取出的顺序一致）容器，元素可以重复，可以插入多个null元素，元素都有索引。常用的实现类有 ArrayList、LinkedList 和 Vector。

**Set 特点**：一个无序（存入和取出顺序有可能不一致）容器，不可以存储重复元素，只允许存入一个null元素，必须保证元素唯一性。Set 接口常用实现类是 HashSet、LinkedHashSet 以及 TreeSet。

另外 List 支持for循环，也就是通过下标来遍历，也可以用迭代器，但是set只能用迭代，因为他无序，无法用下标来取得想要的值。

>  Set和List对比
>
> ​			Set：检索元素效率低下，删除和插入效率高，插入和删除不会引起元素位置改变。
> ​			List：和数组类似，List可以动态增长，查找元素效率高，插入删除元素效率低，因为会引起其他元素位置改变

> set无序，list有序。都没有排序，要实现排序要实现Comparator接口重写compare()方法或者实现Comparable接口重写compareTo()方法。

### Set接口

#### 说一下 HashSet 的实现原理？

HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT，因此 HashSet 的实现比较简单，相关 HashSet 的操作，基本上都是直接调用底层 HashMap 的相关方法来完成，因为HashMap中的key是唯一的，所以HashSet 不允许重复的值。

#### HashSet如何检查重复？HashSet是如何保证数据不可重复的？

- 向HashSet 中add ()元素时，判断元素是否存在的依据，不仅要比较hash值，同时还要结合equles 方法比较。
  HashSet 中的add ()方法会使用HashMap 的put()方法。

- HashMap 的 key 是唯一的，由源码可以看出 HashSet 添加进去的值就是作为HashMap 的key，并且在HashMap中如果K/V相同时，会用新的V覆盖掉旧的V，然后返回旧的V。所以不会重复（ HashMap 比较key是否相等是先比较hashcode 再比较equals ）。

#### ==和equals的区别

　1）对于==，比较的是值是否相等

​		    	如果作用于基本数据类型的变量，则直接比较其存储的 “值”是否相等；

​				如果作用于引用类型的变量，则比较的是所指向的对象的地址

　2）对于equals方法，注意：equals方法不能作用于基本数据类型的变量，equals继承Object类，比较的是是否是同一个对象

　　　　如果没有对equals方法进行重写，则比较的是引用类型的变量所指向的对象的地址；

　　　　诸如String、Date等类对equals方法进行了重写的话，比较的是所指向的对象的内容。

> 1. == 是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同
> 2. == 是指对内存地址进行比较 equals()是对字符串的内容进行比较 
> 3. == 指引用是否相同 equals()指的是值是否相同

> String类、Float类和Double类都重写对于的equals方法，在比较之前都会判断是否同属于Float对象或Double对象，如果不是直接返回false，如果是再继续比较对应的数值大小。

#### hashcode()和equals()的作用、区别、联系

- 因为重写的equal()比较全面实现复杂，所以效率较低。而利用hashCode()进行对比，则只要生成一个hash值进行比较就可以了，效率很高，那么hashCode()既然效率这么高为什么还要equal()呢？
- 因为hashCode()并不是完全可靠，有时候不同的对象他们生成的hashcode也会一样（生成hash值得公式可能存在的问题），所以hashCode()只能说是大部分时候可靠，并不是绝对可靠。

> 总结：
>
> ​		1.equal()相等的两个对象他们的hashCode()肯定相等，也就是用equal()对比是绝对可靠的。
>
>   	  2.hashCode()相等的两个对象他们的equal()不一定相等，也就是hashCode()不是绝对可靠的。

HashSet与HashMap的区别

| HashMap                                                | HashSet                                                      |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| 实现了Map接口                                          | 实现Set接口                                                  |
| 存储键值对                                             | 仅存储对象                                                   |
| 调用put（）向map中添加元素                             | 调用add（）方法向Set中添加元素                               |
| HashMap使用键（Key）计算Hashcode                       | HashSet使用成员对象来计算hashcode值，对于两个对象来说hashcode可能相同，所以equals()方法用来判断对象的相等性，如果两个对象不同的话，那么返回false |
| HashMap相对于HashSet较快，因为它是使用唯一的键获取对象 | HashSet较HashMap来说比较慢                                   |

### Map接口

#### 说一下 HashMap 的实现原理？

**HashMap概述**： HashMap是基于哈希表的Map接口的非同步实现。此实现提供所有可选的映射操作，并允许使用null值和null键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。

**HashMap的数据结构**： 在Java编程语言中，最基本的结构就是两种，一个是数组，另外一个是模拟指针（引用），所有的数据结构都可以用这两个基本结构来构造的，HashMap也不例外。HashMap实际上是一个“链表散列”的数据结构，即数组和链表的结合体。

==HashMap 基于 Hash 算法实现的==

当我们往Hashmap中put元素时，利用key的hashCode重新hash计算出当前对象的元素在数组中的下标
存储时，如果出现hash值相同的key，此时有两种情况。(1)如果key相同，则覆盖原始值；(2)如果key不同（出现冲突），则将当前的key-value放入链表中
获取时，直接找到hash值对应的下标，在进一步判断key是否相同，从而找到对应值。
理解了以上过程就不难明白HashMap是如何解决hash冲突的问题，核心就是使用了数组的存储方式，然后将冲突的key的对象放入链表中，一旦发现冲突就在链表中做进一步的对比。

需要注意Jdk 1.8中对HashMap的实现做了优化，当链表中的节点数据超过八个之后，该链表会转为红黑树来提高查询效率，从原来的O(n)到O(logn)

#### HashMap在JDK1.7和JDK1.8中有哪些不同？HashMap的底层实现

在Java中，保存数据有两种比较简单的数据结构：数组和链表。数组的特点是：寻址容易，插入和删除困难；链表的特点是：寻址困难，但插入和删除容易；所以我们将数组和链表结合在一起，发挥两者各自的优势，使用一种叫做拉链法的方式可以解决哈希冲突。

**JDK1.8之前**

JDK1.8之前采用的是拉链法。拉链法：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。

![image-20200524204854819](C:\Users\CYC\AppData\Roaming\Typora\typora-user-images\image-20200524204854819.png)

 **JDK1.8之后**

相比于之前的版本，jdk1.8在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。

![image-20200524204907957](C:\Users\CYC\AppData\Roaming\Typora\typora-user-images\image-20200524204907957.png)

#### JDK1.7 VS JDK1.8 比较

JDK1.8主要解决或优化了一下问题：

1. resize 扩容优化
2. 引入了红黑树，目的是避免单条链表过长而影响查询效率，红黑树算法请参考
3. 解决了多线程死循环问题，但仍是非线程安全的，多线程时可能会造成数据丢失问题

| 不同                     | JDK 1.7                                                      | JDK 1.8                                                      |
| ------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 存储结构                 | 数组 + 链表                                                  | 数组 + 链表 + 红黑树                                         |
| 初始化方式               | 单独函数：`inflateTable()`                                   | 直接集成到了扩容函数resize()中                               |
| hash值计算方式           | 扰动处理 = 9次扰动 = 4次位运算 + 5次异或运算                 | 扰动处理 = 2次扰动 = 1次位运算 + 1次异或运算                 |
| 存放数据的规则           | 无冲突时，存放数组；冲突时，存放链表                         | 无冲突时，存放数组；冲突 & 链表长度 < 8：存放单链表；冲突 & 链表长度 > 8：树化并存放红黑树 |
| 插入数据方式             | 头插法（先讲原位置的数据移到后1位，再插入数据到该位置）      | 尾插法（直接插入到链表尾部/红黑树）                          |
| 扩容后存储位置的计算方式 | 全部按照原来方法进行计算（即hashCode ->> 扰动函数 ->> (h&length-1)） | 按照扩容后的规律计算（即扩容后的位置=原位置 or 原位置 + 旧容量） |


​		
​		
​		
​		
​		
​	