## 企业面经:writing_hand:

### 一、浙江农信面经:fist_oncoming:

自我介绍

	各位面试官下午好，很高兴能参加今天的面试。我叫曹远超，今年21岁，来自江西九江，就读于江西理工大学，专业是软件开发。
	在校期间，我的学习成绩还不错，大一到大三每一学年都有拿过综合奖学金，大二上学期还拿过一次国家励志奖学金，班级排名一般在前五名以内。
	在大二的时候通过了英语四级、大三通过了英语六级。
	我个人的兴趣爱好比较广泛，听音乐、读书、跑步和打羽毛球都是我空闲时间喜欢做的事。
	在专业方面，我熟悉Java基础、操作系统以及数据库等相关的专业知识，也有自学了解过Spring开源框架和MyBatis持久层框架。
	好的，以上就是我想表述的内容，谢谢大家。
#### 1.线程和进程的区别

**根本区别**：进程是操作系统资源分配的基本单位，而线程是处理器任务调度和执行的基本单位

**资源开销**：每个进程都有独立的代码和数据空间（程序上下文），程序之间的切换会有较大的开销；线程可以看做轻量级的进程，同一类线程共享代码和数据空间，每个线程都有自己独立的运行栈和程序计数器（PC），线程之间切换的开销小。

**包含关系**：如果一个进程内有多个线程，则执行过程不是一条线的，而是多条线（线程）共同完成的；线程是进程的一部分，所以线程也被称为轻权进程或者轻量级进程。

**内存分配**：同一进程的线程共享本进程的地址空间和资源，而进程之间的地址空间和资源是相互独立的

**影响关系**：一个进程崩溃后，在保护模式下不会对其他进程产生影响，但是一个线程崩溃整个进程都死掉。所以多进程要比多线程健壮。

**执行过程**：每个独立的进程有程序运行的入口、顺序执行序列和程序出口。但是线程不能独立执行，必须依存在应用程序中，由应用程序提供多个线程执行控制，两者均可并发执行



另：

**根本区别**：进程是资源分配的最小单位，而线程是程序运行的最小单位

**资源开销**：进程是有独立的内存空间，里面存储着代码段、堆栈段、数据段，而线程是包含在进程里面的，一个进程里有多个线程，并且这些线程都是共享进程中的数据的。因此CPU切换线程和创建线程远比进程的开销要小的多

**程序健壮性**：多进程程序要比多线程程序健壮很多，在多进程程序里一个进程挂掉后，不会影响整个其它进程。但若一个线程挂掉后，整个进程也就挂掉了

**通信**：线程之间因为共享数据字段，所以通信很方便，而进程通信需要其它通信方式

#### 2.父线程和子线程的联系，父线程销毁子线程会怎样

父线程销毁，子线程不会随父线程的结束而导致子线程退出

#### 3.IOC和AOP

IoC指的是控制反转，就是类的实例化工作由原先的程序自己创建，转为由Spring容器控制并注入组合对象

AOP指的是面向切面编程，它是将多个对象中那些与业务无关的功能代码，抽取并封装成一个可重用的模块，这个模块就是切面，并在运行时将其切入进去执行

#### 4.怎么分析解决慢SQL优化，思路



#### 5.创建线程方式

1. 继承Thread类，并重写run() 方法

2. 实现Runable接口，并重写run() 方法

3. 实现Callable接口，并将其作为参数创建FutureTask对象，再将FutureTask对象作为参数创建Thread对象，调用Thread对象的start() 方法

**说一下 runnable 和 callable 有什么区别？**

- Runnable 接口 run 方法无返回值；Callable 接口 call 方法有返回值，是个泛型，和Future、FutureTask配合可以用来获取异步执行的结果
- Runnable 接口 run 方法只能抛出运行时异常，且无法捕获处理；Callable 接口 call 方法允许抛出异常，可以获取异常信息

#### 6.http协议请求方式有哪些，get和post区别

 GET: 完整请求一个资源 （常用）

 HEAD: 仅请求响应首部

 POST：提交表单  （常用）

 PUT: (webdav) 上传文件（但是浏览器不支持该方法）

 DELETE：(webdav) 删除

 OPTIONS：返回请求的资源所支持的方法的方法

 TRACE: 追求一个资源请求中间所经过的代理（该方法不能由浏览器发出）

**区别**

1.Get请求在url中传递的参数长度有限制，post没有

2.Get比Post更不安全，参数放在url中，post参数放在request body中

3.Get请求会被浏览器所Cache，而POST不会

#### 7.session和cookie区别，大小限制

 **1、存储位置：**Cookie和Session都是会话技术，Cookie是运行在客户端，Session是运行在服务器端。

  **2、大小以及个数：**Cookie有大小限制以及个数也有限制，单个Cookie不能大于4k，一个站点最多只能保存20个，Session是没有大小限制，和服务器的内存大小有关。

  **3、安全性：**Cookie有安全隐患，通过拦截或本地文件找得到你的cookie后可以进行攻击。

  **4、存储时间：**Session是保存在服务器端上会存在一段时间才会消失，如果session过多会增加服务器的压力。

Cookie在第一次访问服务器时，保存一个SessionID，目的是为了第二次访问时，将SessionID和数据一并提交给服务器，好让服务器知道该用户是谁。

#### 8.找工作情况，职业规划



#### 9.什么是最小生成树

在连通图的所有生成树中，所有边的权值之和最小的生成树，称为最小生成树

#### 10.排序算法

排序主要分为外部排序和内部排序，其中稳定为:ballot_box_with_check: ,不稳定为:x:

- **外部排序**：
  - 多路归并排序
- **内部排序**：
  - 插入排序：
    - 直接插入排序：
    - 折半插入排序：
    - 希尔排序:x:：
  - 交换排序：
    - 冒泡排序：
    - 快速排序:x:：
  - 选择排序：
    - 简单选择排序:x:：
    - 堆排序:x:：
  - 归并排序
  - 基数排序

#### 11.hashmap和hashtable的区别

底层数据结构是数组和链表的结合体

- **继承的父类不同**： hashmap实现了map接口，而hashtable继承了dictionary抽象类
- **线程安全**： hashmap是非同步的，而hashtable是同步的，这就意味着在多线程中hashmap要实现同步就必须自己手动增加同步处理,hashtable安全但需要加锁所以效率较慢
- **是否允许null值**： Hashmap是允许key和value为null值的，而HashTable键值对都不能为空，否则会报空指针异常。
- **计算hash值方式不同**： HashMap因为Hash冲突变高，所以采用重算Hash值的方法：先调用key的hash值，在将hash值与右移16位后的数据进行异或操作，从而得到新的hash值。而HashTable采用直接调用key的HashCode方法来取得hash值

~~~java
static final int hash(Object key) {
        int h;
        return (key == null) ? 0 : (h = key.hashCode()) ^ (h >>> 16);
    }
~~~

- **扩容方式不同resize（）**：HashMap扩容必须要求为原容量的2倍，而且一定是2的幂次倍扩容结果，而且每次扩容时，原来数组中的元素依次重新计算存放位置，并重新插入；而HashTable扩容为原容量的2倍加1

> Q：Hashtable扩容的数组长度为什么时旧数组长度乘以2加1？
>
> A：Hashtable中数组的长度尽量为素数或者奇数，同时Hashtable采用取模的方式来计算数组下标，这样减少Hash碰撞，计算出来的数组下标更加均匀。但是这样效率会比HashMap利用位运算计算数组下标低。
>
> Q:HashMap初始容量为什么是2的n次幂及扩容为什么是2倍的形式?
>
> A:是因为容量是2的n次幂，可以使得添加的元素均匀分布在HashMap中的数组上，减少hash碰撞，避免形成链表的结构，使得查询效率降低

- **解决hash冲突方式不同（地址冲突）**：HashMap在冲突数量小于8时，使用的是链表方式解决冲突，当冲突数量大于等于8时使用的是红黑树存储；而在HashTable中， 都是以链表方式存储。

#### 12.springboot核心配置文件

application.yml

#### 13.mybatis问的数据库字段名和类属性名不同时怎么做

- **第1种**： 通过在查询的SQL语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。

~~~xml
<select id="getOrder" parameterType="int" resultType="com.jourwon.pojo.Order">
       select order_id id, order_no orderno ,order_price price form orders where order_id=#{id};
</select>
~~~

- **第2种**： 通过`<resultMap>`来映射字段名和实体类属性名的一一对应的关系。

~~~xml
<select id="getOrder" parameterType="int" resultMap="orderResultMap">
	select * from orders where order_id=#{id}
</select>

<resultMap type="com.jourwon.pojo.Order" id="orderResultMap">
    <!–用id属性来映射主键字段–>
    <id property="id" column="order_id">
    <!–用result属性来映射非主键字段，property为实体类属性名，column为数据库表中的属性–>
    <result property ="orderno" column ="order_no"/>
    <result property="price" column="order_price" />
</reslutMap>
~~~

#### #{}和${}的区别

- \#{}是占位符，预编译处理；${}是拼接符，字符串替换，没有预编译处理。
- Mybatis在处理#{}时，#{}传入参数是以字符串传入，会将SQL中的#{}替换为?号，调用PreparedStatement的set方法来赋值。
- Mybatis在处理时，是原值传入，就是把{}时，是原值传入，就是把时，是原值传入，就是把{}替换成变量的值，相当于JDBC中的Statement编译
- 变量替换后，#{} 对应的变量自动加上单引号 ‘’；变量替换后，${} 对应的变量不会加上单引号 ‘’
- #{} 可以有效的防止SQL注入，提高系统安全性；${} 不能防止SQL 注入
- #{} 的变量替换是在DBMS 中；${} 的变量替换是在 DBMS 外

#### 模糊查询like语句该怎么写

（1）’%${question}%’ 可能引起SQL注入，不推荐

（2）"%"#{question}"%" 注意：因为#{…}解析成sql语句时候，会在变量外侧自动加单引号’ '，所以这里 % 需要使用双引号" "，不能使用单引号 ’ '，不然会查不到任何结果。

（3）CONCAT(’%’,#{question},’%’) 使用CONCAT()函数，推荐

（4）使用bind标签

~~~xml
<select id="listUserLikeUsername" resultType="com.jourwon.pojo.User">
　　<bind name="pattern" value="'%' + username + '%'" />
　　select id,sex,age,username,password from person where username LIKE #{pattern}
</select>
~~~

#### 在mapper中如何传递多个参数

**方法1：顺序传参法**

~~~xml
public User selectUser(String name, int deptId);

<select id="selectUser" resultMap="UserResultMap">
    select * from user
    where user_name = #{0} and dept_id = #{1}
</select>
~~~

> \#{}里面的数字代表传入参数的顺序。
>
> 这种方法不建议使用，sql层表达不直观，且一旦顺序调整容易出错

**方法2：@Param注解传参法**

~~~xml
public User selectUser(@Param("userName") String name, int @Param("deptId") deptId);

<select id="selectUser" resultMap="UserResultMap">
    select * from user
    where user_name = #{userName} and dept_id = #{deptId}
</select>
~~~

> \#{}里面的名称对应的是注解@Param括号里面修饰的名称。
>
> 这种方法在参数不多的情况还是比较直观的，推荐使用。

**方法3：Map传参法**

~~~xml
public User selectUser(Map<String, Object> params);

<select id="selectUser" parameterType="java.util.Map" resultMap="UserResultMap">
    select * from user
    where user_name = #{userName} and dept_id = #{deptId}
</select>
~~~

> \#{}里面的名称对应的是Map里面的key名称。
>
> 这种方法适合传递多个参数，且参数易变能灵活传递的情况。

**方法4：Java Bean传参法**

~~~xml
public User selectUser(User user);

<select id="selectUser" parameterType="com.jourwon.pojo.User" resultMap="UserResultMap">
    select * from user
    where user_name = #{userName} and dept_id = #{deptId}
</select>
~~~

> \#{}里面的名称对应的是User类里面的成员属性。
>
> 这种方法直观，需要建一个实体类，扩展不容易，需要加属性，但代码可读性强，业务逻辑处理方便，推荐使用。

#### 14.springmvc核心控制器

![image-20200527080612009](C:\Users\CYC\AppData\Roaming\Typora\typora-user-images\image-20200527080612009.png)

**具体步骤：**

- 第一步：发起请求到前端控制器(DispatcherServlet)
- 第二步：前端控制器请求HandlerMapping查找 Handler （可以根据xml配置、注解进行查找）
- 第三步：处理器映射器HandlerMapping向前端控制器返回Handler，HandlerMapping会把请求映射为HandlerExecutionChain对象（包含一个Handler处理器（页面控制器）对象，多个HandlerInterceptor拦截器对象），通过这种策略模式，很容易添加新的映射策略
- 第四步：前端控制器调用处理器适配器去执行Handler
- 第五步：处理器适配器HandlerAdapter将会根据适配的结果去执行Handler
- 第六步：Handler执行完成给适配器返回ModelAndView
- 第七步：处理器适配器向前端控制器返回ModelAndView （ModelAndView是springmvc框架的一个底层对象，包括 Model和view）
- 第八步：前端控制器请求视图解析器去进行视图解析 （根据逻辑视图名解析成真正的视图(jsp)），通过这种策略很容易更换其他视图技术，只需要更改视图解析器即可
- 第九步：视图解析器向前端控制器返回View
- 第十步：前端控制器进行视图渲染 （视图渲染将模型数据(在ModelAndView对象中)填充到request域）
- 第十一步：前端控制器向用户响应结果

#### 15.专业方面问了简历上的项目，简单介绍一下，运用了什么方法，实现了什么功能



#### 16.java如何创建一个新对象

1. 使用new关键字
2. 使用Class类的newInstance方法
3. 使用Constructor类的newInstance方法
4. 使用clone方法
5. 使用反序列化

#### 17.错误（error）和异常（exception）的区别

Error和Exception都继承自Throwable

==不同之处==

**Error**：

	1. 总是不可控制的（unchecked）
 	2. 经常用来表示系统错误或者底层资源错误
 	3. 不能被应用程序所处理，可能 在系统级被捕捉

**Exception**：

	1. 可以是可被控制（checked）或者不可控制（unchecked）；
 	2. 表示一个由程序员导致的错误；
 	3. 应该在应用程序级被处理；

#### 18.数据库中内连接和外连接的区别

- 内连接：只返回两个表中连接字段相等的行。

- 左外连接：返回包括左表中的所有记录和右表中连接字段相等的记录。

- 右外连接：返回包括右表中的所有记录和左表中连接字段相等的记录。

- 全外连接：返回左右表中所有的记录和左右表中连接字段相等的记录。

####  19.final、finally、finalize 有什么区别？

- final可以修饰类、变量、方法，修饰类表示该类不能被继承、修饰方法表示该方法不能被重写、修饰变量表示该变量是一个常量不能被重新赋值。
- finally一般作用在try-catch代码块中，在处理异常的时候，通常我们将一定要执行的代码方法finally代码块中，表示不管是否出现异常，该代码块都会执行，一般用来存放一些关闭资源的代码。
- finalize是一个方法，属于Object类的一个方法，而Object类是所有类的父类，Java 中允许使用 finalize()方法在垃圾收集器将对象从内存中清除出去之前做必要的清理工作。

#### 20.死锁怎么形成的，如何避免死锁

死锁是指多个事务或者进程在同一资源上相互占用，并请求得到对方的资源，从而导致恶性循环的现象

**死锁产生的四个必要条件是：**

- 互斥条件：保证资源只能为一人所有
- 不可剥夺条件：不能抢夺其他线程已有资源
- 请求并等待条件：想要其他资源
- 循环等待条件：只能在某一方中获取资源

#### 21.进程间的通信方式

- 共享存储：多个线程通过一段共享空间来进行通信，就好像是甲和乙中间有个大布袋，甲和乙交换物品是通过大布袋进行的。甲和乙之间不能直接交换。
- 消息传递：进程通过系统提供的发送消息和接受消息两个原语进行数据交换
- 管道通信：所谓管道就是连接一个读进程和写进程通信的共享文件，又叫pipe文件。它只能是半双工通信

#### 22.方法重写和方法重载

方法重写一般是指子类继承父类的一些方法，并对方法进行一些扩展和功能增强

方法重载一般是在一个类中，多个方法的方法名一样，但参数的个数、类型或者顺序不同，在调用方法时，通过传递给他们的参数不同来决定具体使用哪个方法

#### 23.==与equals的区别

- == ：对于基本数据类型，比较的是两个变量的值是否相等，对于引用型变量，比较的是内存中的地址是否相等

- equals():继承Object类，若没有重写，则比较的引用类型对象的地址是否相等；若有重写，则比较的是引用类型对象所指向的内容

#### 24.sleep和wait区别

- :point_right:==sleep()==:
  - 必须指定时间，不释放锁。 
  - 是Thread类中的一个方法，用于线程休眠，休眠时间结束后，该线程可以自动唤醒。   
- :point_right:==wait()==:
  - 可以不指定时间，也可以指定时间，并立即释放锁。           
  -  是Object类中的一个方法，用于线程等待，如果想要唤醒，必须使用notify()或notifyAll()(不能自动唤醒)。

> ### notify和notifyAll的区别：
>
> 1、notify只唤醒一个线程，也就是只会随机选取一个处于等待池中的线程进入锁池去竞争获取锁的机会；
>
> 2、notifyAll会唤醒所有线程，让所有处于等待池的线程全部进入锁池去竞争获取锁的机会

#### 25.JSP和Servlet的比较

1. **相同点**：

   - JSP和Servlet的Web组件，都运行在Web容器内，都可以接受HTTP请求，并产生HTTP响应，共用相同的会话对象和ServletContext环境对象

   - JSP和Servlet最终为相同的Java类，运行类似的doGet或doPost方法

2. **不同点**：

   - JSP和Servlet编程方式不同，Servlet是纯Java类，而JSP是HTML格式的文本标记文件
   - JSP本身固有生成HTML文本，而Servlet需要在Java的流输出语句中写入HTML标记
   - 运行时，Servlet类直接运行，而JSP文本文件需要经过解析、编译后生成.class类文件后再得以运行

#### 26.Java设计模式

- **适配器模式**：将一个类的接口转换成客户希望的另一个接口，适配器模式能让那些接口不兼容的类可以一起工作
- **建造者模式**：将一个复杂对象的构建与它的表示进行分离，使得构建过程可以创建不同的表示
- **工厂方法模式**：定义一个用于创建对象的接口，但是让子类决定将哪一个类实例化
- **抽象工厂模式**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类
- **单例模式**：确保一个类只有一个实例，并提供一个全局访问点来访问这个唯一实例
  - 饿汉模式的单例类一被加载就会初始化创建唯一实例
  - 懒汉模式使用延迟加载技术，在类加载时不将自己实例化，而是在第一次调用被引用时将自己实例化

#### 27.Spring框架中bean的作用域

Spring框架支持以下五种bean的作用域：

- singleton : bean在每个Spring ioc 容器中只有一个实例。
- prototype：一个bean的定义可以有多个实例。
- request：每次http请求都会创建一个bean，该作用域仅在基于web的Spring ApplicationContext情形下有效。
- session：在一个HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。
- global-session：在一个全局的HTTP Session中，一个bean定义对应一个实例。该作用域仅在基于web的Spring ApplicationContext情形下有效。

> ==注意==： 缺省的Spring bean 的作用域是Singleton。使用 prototype 作用域需要慎重的思考，因为频繁创建和销毁 bean 会带来很大的性能开销。

#### 28.解释不同方式的自动装配，spring 自动装配 bean 有哪些方式？

在Spring框架xml配置中共有5种自动装配：

- no：默认的方式是不进行自动装配的，通过手工设置ref属性来进行装配bean。

- byName：通过bean的名称进行自动装配，如果一个bean的 property 与另一bean 的name 相同，就进行自动装配。

- byType：通过参数的数据类型进行自动装配。

- constructor：利用构造函数进行装配，并且构造函数的参数通过byType进行装配。

- autodetect：自动探测，如果有构造方法，通过 construct的方式自动装配，否则使用 byType的方式自动装配。

> @Autowired默认使用byType来装配属性，如果匹配到类型的多个实例，再通过byName来确定Bean。或者可以使用@Qualifier确定

#### 29.throw 和 throws 的区别是什么？

- throw 关键字用**在方法内部**，只能用于抛出一种异常，用来抛出方法或代码块中的异常，受查异常和非受查异常都可以被抛出。
- throws用**在方法的声明上**，可以标记多个异常。并且一旦有其他方法调用了throws声明的异常的方法，就必须含有处理此类异常的代码，否则也要抛出异常。

#### 30.MySQL存储引擎MyISAM与InnoDB区别

- **Innodb引擎**：Innodb引擎提供了对数据库ACID事务的支持。并且还提供了行级锁和外键的约束。它的设计的目标就是处理大数据容量的数据库系统。它支持hash索引，不支持全文索引
- **MyIASM引擎(原本Mysql的默认引擎)**：不提供事务的支持，也不支持行级锁和外键。它支持全文索引而不支持hash索引
- **MEMORY引擎**：所有的数据都在内存中，数据的处理速度快，但是安全性不高。

#### 31.JAVA和javascript的区别

1. **本质不一样：**Java是跨平台的面向程序设计语言，而JavaScript是直译式脚本语言
2. **执行方式不一样**：Java的源代码在执行之前，必须经过编译；JavaScript是一种解释性编程语言，其源代码不需经过编译，由浏览器解释执行。
3. **用途不一样**：Java应用于PC和移动端，Javascript的用途是:1.嵌入动态文本于HTML页面;2.对浏览器事件做出响应; 3.读写HTML元素;4.在数据被提交到服务器之前验证数据;5.检测访客的浏览器信息; 6.控制cookies，包括创建和修改等。

#### 32.SpringBoot的优点和缺点

#### 33.UDP和TCP的区别

**TCP与UDP基本区别**

1. 基于连接与无连接 
2. TCP要求系统资源较多，UDP较少； 
3. UDP程序结构较简单 
4. 流模式（TCP）与数据报模式(UDP); 
5. TCP保证数据正确性，UDP可能丢包 
6. TCP保证数据顺序，UDP不保证 

> TCP是面向连接的通信，它需要通过三次握手来建立连接，而UDP是面向无连接的通信。由于TCP是面向连接的，所以它是可靠的通信，但是传输速度没有UDP快。

#### 34.抽象类和接口的对比

**相同点**

- 接口和抽象类都不能实例化
- 都位于继承的顶端，用于被其他实现或继承
- 都包含抽象方法，其子类都必须覆写这些抽象方法

**不同点**

| 参数       |                            抽象类                            |                             接口                             |
| ---------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 声明       |                 抽象类使用abstract关键字声明                 |                 接口使用interface关键字声明                  |
| 实现       | 子类使用extends关键字来继承抽象类。如果子类不是抽象类的话，它需要提供抽象类中所有声明的方法的实现 | 子类使用implements关键字来实现接口。它需要提供接口中所有声明的方法的实现 |
| 构造器     |                      抽象类可以有构造器                      |                       接口不能有构造器                       |
| 访问修饰符 |              抽象类中的方法可以是任意访问修饰符              | 接口方法默认修饰符是public。并且不允许定义为 private 或者 protected |
| 多继承     |                 一个类最多只能继承一个抽象类                 |                    一个类可以实现多个接口                    |
| 字段声明   |                 抽象类的字段声明可以是任意的                 |            接口的字段默认都是 static 和 final 的             |

### 二、中创柯达面经:facepunch:

#### 1.什么叫反射机制？

**反射机制是在运行状态中：**

- 对于任意一个类，都能够知道这个类的所有属性和方法。
- 对于任意一个对象，都能够调用它的任意一个方法和属性。

#### 2. 反射的应用?

我们可能听过，Java编写的程序，一次编译，到处运行。这也是Java程序为什么是无关平台的所在，原因在于，java的源代码会被编译成.class文件字节码，只要装有Java虚拟机JVM的地方（Java提供了各种不同平台上的虚拟机制。）.class文件才可以在运行加载。

- 第一步：由Java编译器进行源代码编译，得到相应类的字节码.class文件。
- 第二步：生成class文件之后，通过ClassLoader类加载器加载进内存，Java字节码由JVM执行解释给目标计算机。
- 第三步，目标计算机将结果呈现给我们计算机用户；因此，Java并不是编译机制，而是解释机制.class文件才可以在不同平台上运行加载。

![image-20200608152947054](C:\Users\CYC\AppData\Roaming\Typora\typora-user-images\image-20200608152947054.png)

#### 3. 获得反射入口的三种方式(获得类)

**1).Class.forName(全类名)(推荐使用)**

~~~java
Class<?> classStu = Class.forName("reflect.Student");
		System.out.println(classStu);
~~~

 **2).类名.class**

~~~java
Class<?> classStu2 = Student.class;
	System.out.println(classStu2);
~~~

**3).对象.getClass()**

~~~java
Student stu = new Student();
	Class<?> classStu3 = stu.getClass();
	System.out.println(classStu3);
~~~

#### 4.成员变量与局部变量的区别有哪些

成员变量：方法外部，类内部定义的变量

局部变量：类的方法中的变量。

**成员变量和局部变量的区别**

> **作用域**

- 成员变量：针对整个类有效。
- 局部变量：只在某个范围内有效。(一般指的就是方法,语句体内)

> **存储位置**

- 成员变量：随着对象的创建而存在，随着对象的消失而消失，存储在堆内存中。
- 局部变量：在方法被调用，或者语句被执行的时候存在，存储在栈内存中。当方法调用完，或者语句结束后，就自动释放。

> **生命周期**

- 成员变量：随着对象的创建而存在，随着对象的消失而消失
- 局部变量：当方法调用完，或者语句结束后，就自动释放。

> **初始值**

- 成员变量：有默认初始值。
- 局部变量：没有默认初始值，使用前必须赋值。

